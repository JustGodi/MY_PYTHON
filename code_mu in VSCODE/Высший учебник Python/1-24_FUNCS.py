        # Функции

    # 1

    # Локальная область видимости переменных в Python. Все переменные, находящиеся внутри функции имеют так называемую локальную область видимости - они доступны только в пределах своей функции и во внешнем коде с ними нельзя работать.
'''
def func():
    num = 2
    return num

print(func())
'''
# код ниже выдатс ошибку т.к переменная num задана локально внутри функции и используется только вместе с функцией, её нельзя вызвать вне кода функции
#print(num)

# 1

# Каким будет результат выполнения следующего кода:


'''
def func():
	num = 1

func()
print(num)
'''
# ошибка из-за использования переменной заданной в локальной области видимости

# 2 

# Каким будет результат выполнения следующего кода:
'''
def func():
	num = 3
	print(num)

func()
'''
# вызов функции выполнит код внутри неё, ошибок не будет

# 3

# Каким будет результат выполнения следующего кода:
'''
def func():
    num = 5
    return num

print(func())
'''
# Код выполнится без ошибак, принт функции выведет в консоль 5

        # 2 Глобальная область видимости переменных
    
    # Если перенести переменную num из функции во внешний блок кода, то она приобретет глобальную область видимости и станет доступной не только внутри функции, но и снаружи:
'''
num = 1

def func():
    print(num)

func()
'''
# т.к. переменная задана в глобальной области видимости, то функция может спокойно с ней работать, как и мы можем её ввеси и использовать везде в программе

# 1 

# Каким будет результат выполнения следующего кода:
'''
num = 2

def func():
    return num

func()
print(num)
'''
# Код отработает без ошибок, т.к. переменная задана в глобальной области видимости, и её может использовать как функция так и мы

# 2

# Каким будет результат выполнения следующего кода:
'''
num = 2

def func():
    return num1

print(func())
'''
# выдаст ошибку т.к. функция возвращает переменную которой нет даже в самой функции, и интерпретатор пайтона предлагает прописать имя переменной с num1 на num


        # 3 
    
    # Взаимодействие областей видимости. Бывают случаи, когда внешняя (глобальная) и внутренняя (локальная) переменные имеют одно и тоже имя:
'''
num = 1

def func():
    num = 2
    print(num)

# При этом важно понимать, что локальная num хоть и имеет тоже название, что и глобальная, но для Python является другой переменной. Это значит, что глобальная num НЕ перезаписывается внутри функции, а сохраняет свое первоначальное значение. При вызове функции func в консоль выведется значение только локальной num, а через print - значение глобальной переменной:

func() # выведет 2
print(num) # выведет 1
'''

        # 4 Нюансы работы с областями видимости

    # Рассмотрим важные нюансы работы с локальной и глобальной переменными.
    # Пусть у нас есть глобальная переменная num. Давайте создадим функцию func, которая будет выводить глобальную num в консоль:
'''
num = 1

def func():
    print(num)

func() # выведет 1
'''
    # А теперь объявим локальную num на строке ниже функции print. После выполнения кода в консоль выведется ошибка. Это происходит из-за того, что Python внутри функции воспринимает num только как локальную переменную, которая еще не была объявлена:
'''
num = 1

def func():
    print(num) # выведет ошибку
    num = 2

func()
'''

    # Давайте теперь перепишем код внутри функции так, чтобы значение переменной num увеличилось на 2:
'''
num = 1

def func():
    num += 2 # выведет ошибку

func()
'''
    # Ошибка вызвана тем, что выражение num += 2 представляет собой следующую запись:

    # num = num + 2
    # Однако сама локальная переменная, к которой происходит прибавление еще не объявлена. И соответственно Python выводит ошибку, поскольку нельзя прибавить число к несуществующему значению.

'''
tst = 'abc'

def func():
    txt = tst.upper()
    return txt

print(func())
print(tst)
'''

        # 5 Передача переменных по значению

    # В Python все данные делятся на примитивные (строки, числа) и сложные объекты (списки, множества, словари и т.д.). При этом передача переменных каждого из типов имеет свои особенности. Например, по значению можно передать переменные, принадлежащие только к примитивным типам данных.

    # Пусть у нас есть две переменные. Первая содержит в значении единицу, а вторая переменная равна первой:
'''
num1 = 1
num2 = num1

print(num2) # выведет 1
'''

    # Если после объявления второй переменной перезаписать num1, то значение num2 останется прежним. Это объясняется тем, что в num2 копируется только значение первой переменной. И любые последующие изменения, внесенные в num1 не повлияют на num2. Здесь работает передача переменной по значению:
'''
num1 = 1
num2 = num1
num1 = 3

print(num2) # выведет 1
'''

        # 6 Передача переменных по ссылке

    # В Python переменные, содержащие сложные объекты передаются по ссылке. Это значит, все изменения, сделанные в одной переменной отобразятся на второй. И хотя при таком типе присваивания значений увеличивается риск появления ошибки, зато значительно экономятся ресурсы системной памяти ОС.
'''
lst1 = [1, 2, 3, 4, 5]
lst2 = lst1

    # Поскольку переменной lst2 присвоили значение lst1, теперь в оперативной памяти компьютера хранится один список, на который одновременно ссылаются две переменные. Давайте изменим первый элемент lst2 и выведем первый список в консоль:

lst2[0] = '!'
print(lst1, lst2) # выведет ['!', 2, 3, 4, 5]
'''
'''
lst1 = ['a', 'b', 'c', 'd']

lst2 = lst1
lst3 = 'e'
lst2[2] = lst3

print(lst2, lst1)
'''
# суть в том что когда объявляешь списко/словарь/множество и делаешь присваение этого множества (через знак =) к переменной с другим названием то списко один а вот переменных которые на него ссылаются две, ниже пример как избежать ссылки на один список(как в коде выше) путем копирования списков([:])
'''
lst1 = ['a', 'b', 'c', 'd']

lst2 = lst1[:]
lst3 = 'e'
lst2[2] = lst3

print(lst2, lst1)
'''
# lst1 не поменялся, т.к. м именно копировали один список в другой, и все изменения происходящие в lst2 происходят уже в новом(другом) списке, а не в том же списке на который ссылается два списка

        # 7 Передача примитивов параметрами функций

    # Давайте рассмотрим особенности передачи примитивных типов данных (строки, числа) в параметры функции.
    # Пусть у нас есть функция, которая параметром принимает переменную tst и задает ей значение 2. После функции объявим переменную num:
'''
def func(tst):
    tst = 2
    return print(tst)

num = 3

func(num)
print(num)
# не смотря на то что м задали как аргумент переменную num(т.е. tst = num = 3) то в ходе выполнения функции переменной num(которая в функции является tst) присваивается значение 2
'''

        # 8 Передача объектов параметрами

    # Переменные, содержащие объекты (списки, множества, кортежи, словари) в функциях передаются по ссылке. Давайте перепишем код в функции так, чтобы первый элемент передаваемой переменной менялся на восклицательный знак. А ниже функции объявим переменную, значением которой является список:
'''
def func(tst):
    tst[0] = '!'
    print(tst)

lst = [1, 2, 3, 4, 5]

# Поскольку списки передаются по ссылке, при вызове функции изменится и значение lst в глобальной области видимости:

print(lst) # выведет [1, 2, 3, 4, 5], до изменения переменной из глобальной области видимости
func(lst) # выведет ['!', 2, 3, 4, 5] изменение переменной из глобальной области видимости
print(lst) # выведет ['!', 2, 3, 4, 5] после изменений
'''

        # 9 Функция как переменная

    # В Python функция по своей сути является переменной. И это значит, что ее также можно передавать Пусть у нас есть функция, которая возвращает восклицательный знак:
'''
def func():
    return '!'

print(func)

# После выполнения кода в консоль выведется специальный объект, содержащий информацию о данной функции:
# <function func at 0x0000022816383E20>

# Теперь давайте объявим переменную func2, в значение которой передадим функцию func1. Сама функция будет передаваться не по значению, а по ссылке как объект. И при вызове func2 с круглыми скобками в консоль выведется результат работы func1:

def func_1():
    print('!')

func_2 = func_1

func_2() # выведет '!'
'''

        # 10 Функции-коллбэки

    # В Python есть возможность передавать функции в параметры других функций. При этом функции передаются как переменные (без круглых скобок) и называются коллбэками. Такие функции-коллбэки будут выполняться в теле основной функции.

# Пусть у нас есть функция test, которая параметром принимает число и функцию:
'''
def test(num, func):
    pass


# Теперь давайте создадим функцию func, которая будет возводить число в квадратную степень:

def func(num):
    return num ** 2

# Теперь давайте вернемся к test и в ее теле допишем код, чтобы переданная в параметр функция-коллбэк также параметром принимала число. В итоге получится, что результатом test будет работа другой функции, число для которой будет браться из первого параметра test:

def test(num, func):
    print(func(num))

test(3, func)
'''

        # 11 Передача нескольких параметров в функцию
'''
def func(num_1, num_2):
    return num_1 + num_2

print(func(2, 3))
'''
    # При вызове функции заданные числа 2 и 3 попадут в переменные num1 и num2 соответственно.
    
    # Но бывают случаи, когда нужно при вызове функции передать много параметров, количество которых заранее неизвестно. В Python можно задать при объявлении функции только одну переменную, из которой позже выведется кортеж всех переданных при вызове параметров. Для этого перед данной переменной нужно указать символ *. Такую переменную принято называть args, но можно задать ей и любое другое название. А чтобы вывести все параметры, нужно прописать в теле функции эту переменную, но уже без *:
'''
def func(*args):
    return args

print(func(1, 2, 3))
'''

# Далее с полученными параметрами можно проводить любые другие операции. Давайте получим их сумму:
'''
def func(*args):
    return sum(args)

print(func(1, 2, 3))
'''

# 1 

# Напишите функцию, которая будет принимать в качестве параметров неограниченное количество имен пользователей и выводить их в консоль в виде кортежа.
'''
def func(*args):

    return args
    """ниже код полное говно исходя из тз"""
    """выше код правильный и в разы проще"""
    """
    txt = ''
#    for el in args:
#        print(tuple(el))
    
    for el in args:
        print(tuple(el.split()))
    
    return ''
    """

print(func('asd', 'qwe', 'zxc'))
'''

        # 12 Комбинирование обычных параметров и *args

    # В функции можно комбинировать обычные параметры и *args. Только в этом случае *args должны всегда стоять на последнем месте. Давайте добавим к нашей функции два дополнительных числовых параметра и выведем их в консоль вместе с *args:
'''
def func(num_1, num_2, *args):
    print(num_1, num_2, args)

print(func(1, 2, 3, 4, 5))
'''

# Каким будет результат выполнения следующего кода:
'''
def func(num1, num2, *args):
    return sum(args) + (num1 * num2)

print(func(10, 5, 1, 2, 3))
'''

        # 13 Вывод именованных параметров в виде словаря

    # Именованные параметры, передаваемые в функции, можно вывести в виде словаря. Делается это с помощью символа ** и переменной kvargs. Давайте объявим функцию, которая будет просто выводить два именованных параметра в консоль:
'''
def func(**kvargs):
    print(kvargs)

func(num_1=1, num_2=2)
'''

# 1

# Создайте функцию, которая будет принимать в параметры числа от 1 до 7. Назовите эти параметры по дням недели и выведите их в виде словаря.
'''
def func(**kvargs):
    print(kvargs)

func(monday=1, tuesday=2, wednesday=3, thursday=4, friday=5, saturday=6, sunday=7)
'''

# 2

# Создайте функцию, которая будет принимать возраст пользователей в виде именованных параметров и выводить их в виде словаря.
'''
def ages(**kvargs):
    print(kvargs)

ages(John=23, Oleg=25, Artem=24, Sergey=24)
'''

        # 14 Комбинирование параметров

    # В одну и ту же функцию можно одновременно передать именованные и позиционные параметры. Делается это с помощью символа *, который обозначает, что параметры указанные справа от него следует считать именованными, если их значения по умолчанию не нужно использовать. (погуглил * имеет много применений)

    # Давайте создадим функцию, которая будет выводить все параметры в консоль. Переменная data будет обозначать обычный позиционный параметр. Далее после символа * задаются две переменные start и end с дефолтными значениями. Однако при вызове функции сделаем эти переменные именованными:
'''
def func(data, *, start=0, end=100):
    print(data, start, end)

func(1, start=2, end=3)
func(1, start=3, end=2)
func(1)
'''

# Если же убрать дефолтное значение переменной start и в то же время убрать ее как именованный параметр, то выведется ошибка. Это происходит потому, что символ * уже определил start как именованную переменную:
'''
def func(data, *, start, end=100):
    print(data, start, end)

func(1, 2, end=3)
# Да, выдало огибку func() takes 1 positional argument but 2 positional arguments (and 1 keyword-only argument) were given
'''

        # 15 Вывод документации функции

    # В теле функции можно прописать строку, описывающую суть проводимой работы. Такую строку принято считать документацией функции. Она заключается в одинарные кавычки и размещается в первой строке тела функции. Чтобы ее прочитать, нужно использовать специальную функцию help, в параметр который передается имя функции.

    # Пусть у нас есть функция, суммирующая два числа. Об этом оставлена строка с соответствующей информацией:
'''
def get_sum(num_1, num_2):
    'this func sums two numbers'
    return num_1 + num_2

help(get_sum)

# С помощью функции help можно читать документацию и стандартных функций. Давайте узнаем информацию о функции print:

help(print)

# Для того, чтобы вывести только строку с документацией из функции, нужно передать в help после имени функции служебную конструкцию .__doc__:

help(print.__doc__)
'''

# 1

# Создайте функцию, которая будет принимать параметром список названий месяцев и выводить их с заглавной буквы. Опишите суть работы функции в документации и выведите ее в консоль.
'''
def months(list):
    'print months names title'
    for el in list:
        print(el.title())

lst = ['january', 'february', 'march',
        'april', 'may', 'june', 
        'july', 'august', 'september', 
        'october', 'november', 'december'
        ]

months(lst)
help(months)
'''

# 2

# Выведите всю документацию о функции sum.
'''
help(sum)
'''

# 3

# Выведите только строку с документацией о функции len.
'''
help(len)
'''

        # 16 Лямбда-функция

    # Пусть у нас есть функция func, которая параметрами принимает список и коллбэк. Функция будет создавать новый список из элементов исходного списка. При этом к каждому из элементов применится коллбэк:
'''
def func(lst, callback):
    res = []

    for el in lst:
        res.append(callback(el))
    
    return res

# Теперь создадим функцию square, которая будет возводить переданное ей число в квадрат:

def square(num):
    return num ** 2

# Давайте передадим в параметры func числовой список и функцию square в качестве коллбэка:

print(func([1, 2, 3], square))

# В консоль выведется новый список, состоящий из квадратов чисел


# Однако данный код можно значительно сократить, используя лямбда-функцию - анонимную функцию, которая вызывается с помощью ключевого слова lambda и записывается в одной строке. Поэтому в лямбда-функцию можно переписать только функции, код которых занимает одну строку.

#Синтаксис лямбда-функции выглядит вот так:

#lambda параметр функции: операция с параметром функции 

# Давайте перепишем функцию square с помощью лямбда-функции и передадим ее в параметр func:

print(func([1, 2, 3], lambda num: num **2))

# Лямбда-функцию можно записать в переменную:

square_2 = lambda num: num **2

print(func([1, 2, 3], square_2))
'''

# 1

# Перепишите следующий код через лямбда-функцию:
'''
def func(num, clb):
    return clb(num)

def clb(num):
    return num + 1

print(func(2, clb))

print(func(2, lambda num: num + 1))
'''

# 2

# Перепишите следующий код через лямбда-функцию:
'''
def func(num, clb_1, clb_2):
    return (clb_1(num), clb_2(num))

def clb_1(num):
    return num + 1

def clb_2(num):
    return num - 1

print(func(2, clb_1, clb_2))

print(func(2, lambda num: num + 1, lambda num: num - 1))
'''

# 3 

# Перепишите следующий код через лямбда-функцию:
'''
def func(num_1, num_2, clb):
    res = clb(num_1) + num_2
    return res

def clb(num):
    return num ** 3

print(func(2, 6, clb))
'''
'''
def func(num_1, num_2, clb):
    res = clb(num_1) + num_2

    return res

print(func(2, 6, lambda num_1: num_1 ** 3))
'''

        # 17 Функция map для итерации объектов

    # Пусть у нас есть функция square для возведения чисел в квадрат. И есть список, к элементам, которого нужно применить данную функцию:
'''
def square(num):
    return num ** 2

lst = [2, 3, 6, 8, 15]

    # В Python чтобы решить данную задачу, можно использовать специальную функцию map. Она принимает параметрами функцию и список, к элементам которого ее нужно применить. Давайте воспользуемся map для решения примера:

res = map(square, lst)
print(res)

    # Каждый список как и любой сложный объект занимает много места в системной памяти Python. Поэтому для экономии ресурсов после выполнения кода вернется не новый список, а специальный итерируемый map-объект:

for el in res:
    print(el)

    # Чтобы создать из map-объекта новый список, нужно применить к нему функцию list:

res = list(map(square, lst))
print(res)

    # Также при работе с функцией map в первом параметре можно задать лямбда-функцию. Давайте перепишем предыдущий пример с помощью лямбда-функции:

res = map(lambda num: num ** 2, lst)
print(list(res))
'''

# 1

# Перепишите следующий код через лямбда-функцию:
'''
def func(num):
    return num + 1

lst = list(range(1, 6))
res = map(func, lst)
print(list(res))
'''
'''
lst = list(range(1, 6))
res = map(lambda num: num + 1, lst)
print(res, list(res))
'''

# 2

# Перепишите следующий код через лямбда-функцию:
'''
def func(txt):
    return txt[::-1]

lst = ['123', '456', '789']
res = map(func, lst)

print(list(res))
'''
'''
lst = ['123', '456', '789']
print(list(map(lambda el: el[::-1], lst)))
'''

        # 18

    # Функция filter для фильтрации объектов

    # Давайте теперь изучим функцию filter. Она позволяет отфильтровать элементы списков и прочих итерируемых объектов по какому-либо условию. Первым параметром она принимает функцию, которая задает условие для проверки. Во втором параметре указывают список, элементы которого будут фильтроваться. Если функция возвращает True, то элемент остается в новом списке. Если возвращается False, то элемент не войдет в список.
'''
lst = list(range(1, 11))

    # Давайте оставим в нем только четные числа. Для этого с помощью лямбда-функции пропишем, чтобы переданное в ее параметр число делилось на 2 без остатка:

res = filter(lambda num: num % 2 == 0, lst)
print(list(res))
'''

# 1

# Запишите в новый список только нечетные числа из этого списка.
'''
lst = list(range(1, 11))

res = filter(lambda num: num % 2 == 1, lst)
print(list(res))
print(list(filter(lambda num: num % 2 == 1, lst)))
'''

# 2 

# Запишите в новый список только строки, длина которых равна 2.
'''
lst = ['abcd', 'ab', 'c', 'de', 'bc']
res = filter(lambda el: len(el) == 2, lst)

print(list(res))
'''

        # 19 Инструкция global

    # Пусть у нас есть внешняя глобальная переменная i. Также есть функция func, которая прибавляет к этой переменной единицу:
'''
i = 0
def func():
    i += 1 # выдаст ошибку при вызове функции 
    return i
'''
    # После выполнения кода вернется ошибка, потому что происходит конфликт глобальной i, объявленной во внешней коде, и локальной i, к которой прибавляется 1, но сама переменная еще не объявлена. Для того, чтобы исправить данную проблему и задать функции работу именно с глобальной переменной, нужно использовать инструкцию global. Эта инструкция представляет собой объявление, которое выполняется для всего текущего блока кода, в котором оно задано.
'''
i = 0
def func():
    global i
    i += 1
    return i

print(func())
'''

# 1 В следующем коде некоторый программист допустил ошибку: Что не так с этим кодом? Найдите и исправьте ошибку автора кода.
'''
num = 4

def func():
    num *= 2
    return num

print(func())
# ошибка в том что в функции используется переменная из глобальной обласи функции, нужно в функции применить инструкицию global для переменной num
'''
'''
num = 4
def func():
    global num
    num *= 2
    return num

print(func())
'''

# 2 В следующем коде некоторый программист допустил ошибку: Что не так с этим кодом? Найдите и исправьте ошибку автора кода.
'''
num = 10

def func():
    num -= 3
    return i

print(func())
# ошибка таже что и в прошлом примере, только еще ф-ия возвращает переменную которая вообще не объявлена
'''
'''
num = 10

def func():
    global num
    num -= 3
    return num

print(func())
'''

        # 20 

    # Функция в функции

    # В Python внутри одних функций можно объявлять другие. Пусть у нас есть внешняя функция outer, внутри которой находится функция inner:
'''
def outer():
    def inner():
        pass
'''

    # Приведенный выше пример выглядит достаточно просто. Однако часто бывают ситуации, когда в теле функции outer помимо inner выполняются еще и другие операции. Для упрощения кода можно было бы вынести inner во внешний блок кода, однако данная функция будет использована только один раз и только внутри функции outer. Поэтому выносить ее за пределы не имеет смысла.

    # Давайте рассмотрим пример, когда в функцию outer передается список. А с помощью функции inner числовой элемент списка будет возводиться в квадратную степень. Для этого после функции inner объявляем пустой список res, в котором будут накапливаться элементы, возведенные в квадрат в цикле:
'''
def list_of_squares(lst):
    def inner(num):
        return num ** 2
    
    res = []

    for el in lst:
        res.append(inner(el))
    
    return res

lst = list(range(1, 11))

print(list_of_squares(lst))
'''

# 1

# Напишите внешнюю и внутреннюю функции, совместная работа которых будет выводить каждый строчный элемент списка с заглавной буквы.
'''
def output_titled_el(lst):
    'Выводит все элементы списка с заглавной буквы'
    

    def titled_el(let):
        'Делает элементы с заглафной буквы'
        return let.title()
    
    for el in lst:
        print(titled_el(el))

lst = ['asd', 'Avdd', 'qwe', 'reghtj', '1234']

output_titled_el(lst)
'''

# 2 

# Даны функции: Перепишите код так, чтобы func1 была внутренней функцией для func2.
'''
def func1(num):

    if num > 0:
        num += 2
    
    return num

def func2(iter):
    res = []

    for el in iter:
        res.append(func1(el))

    return res
'''
'''
def list_of_increased_positive_numbers(lst):
    'Собирает список из положительных чисел'

    def increase_positive_number(num):
        'Прибавляет к числу 2'
        num += 2
        return num
    
    res = []

    for num in lst:
        if num > 0:
            res.append(increase_positive_number(num))
    return res

lst = [-1, 2, 3, -1, -2, -5, 3, -8, -98, 98]

print(list_of_increased_positive_numbers(lst))
'''

        # 21 
    
    # Инструкция nonlocal

    # Бывают случаи, когда во внешней функции есть переменная, к которой нужно получить доступ во внутренней функции. Объявим в функции outer переменную i. По отношению к внутренней функции данная переменная будет являться внешней (глобальными являются переменные, объявленные ТОЛЬКО во внешнем коде). А функции inner зададим прибавление к i единицу:
'''
def outer():
    i = 0

    def inner():
        i += 1

    inner()

    return i
# ОШИБКА: UnboundLocalError: cannot access local variable 'i' where it is not associated with a value
print(outer())
'''

    # Однако для inner переменная i является локальной, Python считает ее необъявленной и выводит соответствующую ошибку. Раньше подобная ошибка исправлялась с помощью инструкции global. Однако здесь i является внешней переменной, поэтому следует использовать инструкцию nonlocal. Она берет перечисленные имена переменных в ближайшую область видимости, исключая глобальную, т.е. i внутри inner будет взята с переменной, объявленной выше данной функции:
'''
def outer():
    i = 0

    def inner():
        nonlocal i
        i += 1

    inner()

    return i

print(outer())
'''

# 1

# В следующем коде некоторый программист допустил ошибку: Что не так с этим кодом? Найдите и исправьте ошибку автора кода.
'''
num = 10

def outer():
    num = 5

    def inner():
        num -= 2

    inner()

    return num

print(outer())
'''
'''
num = 10

def outer():
    num = 5

    def inner():
        nonlocal num
        num -= 2

    inner()

    return(num)

print(outer())
'''

# 2

# В следующем коде некоторый программист допустил ошибку: Что не так с этим кодом? Найдите и исправьте ошибку автора кода.
'''
num = 3

def outer():
    num += 1
    tst = num

    def inner():
        tst = tst ** 3

    inner()

    return tst

print(outer())
'''
'''
num = 3

def outer():
    global num
    num += 1
    tst = num

    def inner():
        nonlocal tst
        tst **= 3

    inner()

    return(tst)

print(outer())
'''

        # 22

    # Нюансы при работе с внутренней функцией

    # В Python могут быть не только вложенные функции, но и одна функция может возвращать другую. Например, пусть функция outer возвращает как результат исходный код функции inner:
'''
def outer():
    def inner():
        return '+++'

    return inner()
print(outer())

res = outer()
print(res)

res_2 = outer
print(res_2)
print(res_2())
'''

        # 23 Замыкания

    # Под замыканием (англ. closure) подразумевают функцию вместе со всеми внешними переменными, которые ей доступны.

    # В Python чаще всего, говоря "замыкание функции", имеют ввиду не саму эту функцию, а именно ее внешние переменные.

    # Пусть у нас есть следующая функция outer, в которой объявлена переменная i и внутренняя функция inner. В ней к i будет прибавляться единица. Чтобы переменная i корректно работала, добавляем к ней инструкцию nonlocal:
'''
def outer():
    i = 0
    #print('111')
    #print(i)
    def inner():
        nonlocal i
        i+= 1
        #print('333')
        print(i)
        #print('333')
    #print('222')
    #print(i)
    return inner

    # Теперь давайте положим внешнюю функцию в переменную res и вызовем ее с круглыми скобками:
res = outer()
res()
    # Давайте несколько раз вызовем res. После выполнения кода каждый раз счетчик i будет увеличиваться на единицу:

res()
res()
res()
    # Однако здесь есть важный нюанс - каждый вызов функции outer будет увеличивать свой счетчик. Давайте первый вызов outer запишем в переменную res1, а второй вызов - в переменную res2. Затем последовательно выведем их в консоль:

res_1 = outer()
res_1()
res_1()
res_1()
res_1()

res_2 = outer()
res_2()
res_2()
res_2()
res_2()

res()
'''

# 2

# Сделайте функцию, каждый вызов которой будет вызывать следующее число Фибоначчи.
'''
def fibanacci():
    i = 1
    b = 1
    c = 0


    def amount():
        nonlocal i
        nonlocal b
        nonlocal c
        c = i + b
        i = b
        b = c
        print(c)
        print('')

    return amount
# ПОЛЧАСА УБИЛ НА ТО ЧТО ЧТОТО БЫЛО НЕПРАВИЛЬНЫМ, ПОТОМУЧТО В RETURN передавал amount() И ПАЙТОН ВЫПОЛНЛ ФУНКЦИЮ AMOUNT() И ВОЗВРАЩАЛ ЕЁ РЕЗУЛЬТАТ, А Т.К. САМА ФУНКЦИЯ AMOUNT() НЕ ИМЕЕТ RETURN ТО ОНА ВОЗВРАЩАЕТ NONE. ПОЭТОМУ В ФУНКЦИИ FIBANACCI() ДЛЯ RETURN AMOUNT() НУЖНО УБРАТЬ СКОБКИ, Т.Е. RETTURN AMOUNT ЯВЛЯЕТСЯ ПРАВИЛЬНОЙ ЗАПИСЬЮ, ЧТОБЫ RETURN У FIBANACCI ВОЗВРАЩАЛ САМУ ФУНКЦИЮ, А НЕ ЕЕ РЕЗУЛЬТАТ И ФУНКЦИЯ МОГЛА ЗАМКНУТЬСЯ НА СЕБЕ
res = fibanacci()
res()
res()
res()
res()
res()
res()
res()
res()
res()
res()
res()
res()
res()
res()
res()
res()
res()
'''


# 3

# Сделайте функцию, которая будет выдавать случайное целое число в промежутке, но так, чтобы два раза подряд не было одинаковых.

'''
import random

def create_unique_random(start, end):
    previous = None

    def get():
        nonlocal previous
        while True:
            number = random.randint(start, end)
            if number != previous or start == end:
                previous = number
                return number
    return get

# Пример использования:
random_number = create_unique_random(1, 10)



for _ in range(10):
    print(random_number())
'''


'''print(random_number())
print(random_number())
print(random_number())
print(random_number())
print(random_number())
print(random_number())
print(random_number())
print(random_number())
print(random_number())
print(random_number())
print(random_number())
print(random_number())
print(random_number())
print(random_number())
print(random_number())
print(random_number())
print(random_number())
print(random_number())
print(random_number())'''

        # 24 Рекурсия в Python

    # В программировании есть такое понятие, как рекурсия - когда функция вызывает сама себя.

    # Пример 1. Простая рекурсия со счетчиком

    #Давайте выведем с помощью рекурсии числа от 1 до 10:
'''
i = 1

def func():
    global i
    print(i)
    i += 1

    if i <= 10:
        func()

func()
'''

    # Пример 2. Рекурсия для вывода элементов вложенных списков

    # Наиболее часто рекурсии применяются для перебора списков разной степени вложенности. Пусть у нас есть следующий список:

    #Давайте создадим функция, которая переберет его. В ней сначала нужно задать условие, чтобы элемент, который является примитивом, т.е. просто извлеченным из списка числом, выводился в консоль. А если элемент является объектом, например, вложенным списком, то пусть в этом случае функция вызовет сама себя, т.е. произойдет рекурсия. Для проверки типа элемента применим функцию isinstance. Только для нашего примера в первый параметр isinstance пропишем el, а вторым - тип list:

'''
lst = [1, [2, 3], [[4, 5], [6, 7, 8, [9]]]]

def func(lst):
    for el in lst:
        if isinstance(el, list):
            func(el)
        else:
            print(el)

    # При вызове функции выведется ряд всех чисел из вложенного списка:

func(lst)
'''

        # Пример 3. Рекурсия для операций с элементами вложенных списков

    # Рекурсии можно применять и для различных операций с элементами вложенных списков. Пусть у нас есть следующий список:

    # Давайте получим сумму всех его элементов. Для этого в функции объявим переменную res, в которую будет накапливаться сумма чисел. В условии пропишем, что если элемент является сложным объектом, то он попадает в параметре функции func и прибавляется к сумме. Это значит, что элемент будет находиться в рекурсии пока не станет примитивом. И в этом случае он просто прибавится к сумме, записанной в res:

'''
lst = [1, [2, 3], [[4, 5], [6, 7, 8, [9]]]]

def func(lst):
    res = 0
    for el in lst:
        if isinstance(el, list):
            res += func(el)
        else:
            res += el
    return res

print(func(lst))
'''

        # Пример 4. Рекурсия для накопления в список

    # С помощью рекурсии можно разложить вложенные списки в один одномерный список. Пусть у нас есть следующий список:

    # Давайте пропишем в функции пустой список res, в который будут накапливаться элементы исходного списка. Далее запустим цикл и зададим условие - если элемент является списком, то он попадет в метод extend. Этот метод присоединяет элементы одного списка в конец второго списка, т.е. элементы вложенного списка попадут в конец списка res:
'''
lst = [1, [2, 3], [[4, 5], [6, 7, 8, [9]]]]

def func(lst):
    res = []
    for el in lst:
        if isinstance(el, list):
            res.extend(func(el))
        else:
            res.append(el)
    return res

print(func(lst))
'''

# Практические задачи

# 1 Выведите все числовые элементы словаря произвольного уровня вложенности:
'''
dct = {
    'a': {
        'b': 1,
        'c': 2,
        'd': {
            'e': 3,
            'f': 4
        }
    },
    'j': {
        'h': 5,
        'k': 6,
    },
    'l': 7
}

def print_values(dct):
    for value in dct.values():
        if isinstance(value, dict):
            print_values(value)
        else:
            print(value)

print_values(dct)
'''

# 2 Найдите сумму элементов словаря из предыдущей задачи.
'''
dct = {
    'a': {
        'b': 1,
        'c': 2,
        'd': {
            'e': 3,
            'f': 4
        }
    },
    'j': {
        'h': 5,
        'k': 6,
    },
    'l': 7
}

def sum_of_values(dct: dict) -> int:
    res = 0
    for value in dct.values():
        if isinstance(value, dict):
            res += sum_of_values(value)
        else:
            res += value
    return res

print(sum_of_values(dct))
'''

# 3 Получите список примитивных элементов словаря из предыдущей задачи.
'''
dct = {
    'a': {
        'b': 1,
        'c': 2,
        'd': {
            'e': 3,
            'f': 4
        }
    },
    'j': {
        'h': 5,
        'k': 6,
    },
    'l': 7
}

def all_items(dct: dict):
    for item in dct.items():
        key, value = item
        if isinstance(value, dict):
            all_items(value)
        else:
            print(item)

all_items(dct)
'''


























































































