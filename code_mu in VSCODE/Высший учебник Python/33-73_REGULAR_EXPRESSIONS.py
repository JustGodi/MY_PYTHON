            # Введение в регулярные выражения в Python

        # 33
        
        # Регулярные выражения - это команды для сложного поиска и замены (или просто поиска). Они позволяют делать очень интересные вещи, но, к сожалению, довольно тяжелы в освоении.

        # Чтобы начать работу с регулярными выражениями в Python, нам нужно импортировать специальный модуль re:

import re
        # Модуль re включает в себя методы, предназначенных для работы с регулярными выражениями. Регулярное выражение представляет собой набор команд и состоит из двух типов символов: из тех, которые обозначают сами себя и из символов-команд, которые называются специальные символы.

        # Знакомство с регулярными выражениями лучше начать на примере метода sub, который используется для замен в строке. Первым параметром метод принимает что менять, вторым - на что менять. В третьем параметре указываем строку, в которой нужно сделать замену. В четвертом необязательном параметре задаем количество замен. Самая простая замена с помощью данного метода будет выглядеть вот так:

'''
res = re.sub('a', '!', 'bab')
print(res)
'''

        # Как вы заметили, в регулярном выражении буквы обозначают сами себя. Тоже самое относится и к цифрам. Давайте заменим цифру 2 на !:

'''
res = re.sub('2', '!', '12abc3')
print(res)
'''

        # А вот точка является специальным символом и обозначает любой символ. В следующем примере давайте найдем подстроку по такому шаблону: буква 'x', затем любой символ, затем опять буква 'x':

'''
res = re.sub('x.x', '!', 'xax eee')
print(res)
'''

# 1

# Дана строка: txt = 'ahb acb aeb aeeb adcb axeb' Напишите регулярку, которая найдет строки 'ahb', 'acb', 'aeb' по шаблону: буква 'a', любой символ, буква 'b'.

'''
txt = 'ahb acb aeb aeeb adcb axeb'
print(txt)

txt = re.sub('a.b', '!', txt)
print(txt)
'''

# 2

# Дана строка: txt = 'aba aca aea abba adca abea' Напишите регулярку, которая найдет строки 'abba', 'adca', 'abea' по шаблону: буква 'a', 2 любых символа, буква 'a'.

'''
txt = 'aba aca aea abba adca abea'
print(txt)

txt = re.sub('a..a', '!', txt)
print(txt)
'''

# 3

# Дана строка: txt = 'aba aca aea abba adca abea' Напишите регулярку, которая найдет строки 'abba' и 'abea', не захватив 'adca'.

'''
txt = 'aba aca aea abba adca abea'
print(txt)

txt = re.sub('ab.a', '!', txt)
print(txt)
'''

        # 34

        # Операторы повторения символов в регулярках

        # Бывают ситуации, когда нужно указать, что символ повторяется заданное количество раз. Если точное число повторений неизвестно, то можно просто написать его несколько раз - 'aaaa'. Но что делать, если нужно сказать такое: повторить один или более раз?

        # Для этого существуют операторы (квантификаторы) повторения: плюс + (один и более раз), звездочка * (ноль или более раз) и вопрос ? (ноль или один раз). Эти операторы действуют на тот символ, который стоит перед ними.

'''

# Найдем все подстроки по шаблону буква 'x', буква 'a' один или более раз, буква 'x':

txt = 'xx xax xaax xaaax xbx'
print(txt)
res = re.sub('xa+x', '!', txt)
print(res)
'''

'''
# Найдем все подстроки по шаблону буква 'x', буква 'a' ноль или более раз, буква 'x':

txt = 'xx xax xaax xaaax xbx'
print(txt)
res = re.sub('xa*x', '!', txt)
print(res)
'''

'''
# Найдем все подстроки по шаблону буква 'x', буква 'a' ноль или один раз, буква 'x':

txt = 'xx xax xaax xbx'
print(txt)
res = re.sub('xa?x', '!', txt)
print(res)
'''

# 1

# Дана строка: txt = 'aa aba abba abbba abca abea' Напишите регулярку, которая найдет строки 'aba', 'abba', 'abbba' по шаблону: буква 'a', буква 'b' любое количество раз, буква 'a'.
 
'''
txt = 'aa aba abba abbba abca abea'
print(txt)
txt = re.sub('ab+a', '!', txt)
print(txt)
'''

# 2

# Дана строка: txt = 'aa aba abba abbba abca abea' Напишите регулярку, которая найдет строки 'aa', 'aba', 'abba', 'abbba' по шаблону: буква 'a', буква 'b' любое количество раз (в том числе ни одного раза), буква 'a'.

'''
txt = 'aa aba abba abbba abca abea'
print(txt)
txt = re.sub('ab*a', '!', txt)
print(txt)
'''

# 3

# Дана строка: txt = 'aa aba abba abbba abca abea' Напишите регулярку, которая найдет строки 'aa', 'aba' по шаблону: буква 'a', буква 'b' один раз или ни одного, буква 'a'.

'''
txt = 'aa aba abba abbba abca abea'
print(txt)
txt = re.sub('ab?a', '!', txt)
print(txt)
'''

        # 35

        # Группирующие скобки в регулярках Python

        # В предыдущих примерах операторы повторения действовали только на один символ, который стоял перед ними. Что делать, если нужно подействовать им на несколько символов?

        # Для этого существуют группирующие скобки '(' и ')'. Они работают так: если что-то стоит в группирующих скобках и сразу после ')' стоит оператор повторения - он подействует на все, что стоит внутри скобок.

        # В следующем примере шаблон поиска выглядит так: буква 'x', далее строка 'ab' один или более раз, потом буква 'x':

'''
txt = 'xabx xababx xaabbx'
print(txt)
txt = re.sub('x(ab)+x', '!', txt)
print(txt)
'''

# 1

# Дана строка: txt = 'ab abab abab abababab abea' Напишите регулярку, которая найдет строки по шаблону: строка 'ab' повторяется 1 или более раз.

'''
txt = 'ab abab abab abababab abea'
print(txt)
txt = re.sub('(ab)+', '!', txt)
print(txt)
'''

        # 36

        # Экранировка спецсимволов в регулярках Python

        # Предположим, что нужно сделать так, чтобы спецсимвол обозначал сам себя. Для этого его следует экранировать с помощью обратного слеша. Давайте посмотрим на примерах.

        # В следующем примере автор регулярки хотел, чтобы шаблон поиска выглядел так: буква 'a', затем плюс '+', затем буква 'x'. Однако, автор кода не заэкранировал символ '+' и поэтому шаблон поиска самом деле он выглядит так: буква 'a' один или более раз, потом буква 'x':

'''
txt = 'a+x ax aax aaax'
print(txt)
txt = re.sub('a+x', '!', txt)
print(txt)
'''

        # А сейчас автор заэкранировал плюс обратным слешем. Теперь шаблон поиска выглядит так, как надо: буква 'a', затем плюс '+', затем буква 'x':

'''
txt = 'a+x ax aax aaax'
print(txt)
txt = re.sub('a\\+x', '!', txt)
print(txt)
'''

        # В данном примере шаблон выглядит так: буква 'a', затем точка '.', затем буква 'x':

'''
txt = 'a.x abx azx'
print(txt)
txt = re.sub('a\\.x', '!', txt)
print(txt)
'''


        # А следующем примере автор забыл заэкранировать слеш и под регулярку попали все подстроки, так как незаэкранированная точка обозначает любой символ:

'''
txt = 'a.x abx azx'
print(txt)
txt = re.sub('a.x', '!', txt)
print(txt)
'''

        # Список специальных символов и обычных

        # Если экранировать обычный символ - ничего страшного не случится - он все равно будет обозначать сам себя. Исключение - цифры, их нельзя экранировать.

        # Часто возникает сомнение, является ли данный символ специальным. Некоторые доходят до того, что экранируют все подозрительные символы подряд. Однако, это плохая практика (захламляет регулярку обратными слешами).

        # Являются спецсимволами: $ ^ . * + ? \ / {} [] () |

        # Не являются спецсимволами: @ : , ' " - _ = < > % # ~ `& !

# 1

# ВСЕ ДВОЙНЫЕ СЛЕШИ ЗАМЕНИТЬ НА ОРДИНАРНЫЕ МЕНЯ ЗАЕБАЛА ОШИБКА
# Неподдерживаемая escape-последовательность в строковом литерале

# Дана строка: txt = 'a.a aba aea' Напишите регулярку, которая найдет строку 'a.a', не захватив остальные.

'''
txt = 'a.a aba aea'
print(txt)
txt = re.sub('a\\.a', '!', txt)
print(txt)
'''

# 2 

# Дана строка: txt = '2+3 223 2223' Напишите регулярку, которая найдет строку '2+3', не захватив остальные.

'''
txt = '2+3 223 2223'
print(txt)
txt = re.sub('2\\+3', '!', txt)
print(txt)
'''

# 3

# Дана строка: txt = '23 2+3 2++3 2+++3 345 567' Напишите регулярку, которая найдет строки '2+3', '2++3', '2+++3', не захватив остальные (+ может быть любое количество).

'''
txt = '23 2+3 2++3 2+++3 345 567'
print(txt)
txt = re.sub('2\\++3', '!', txt)
print(txt)
'''

# 4

# Дана строка:txt = '23 2+3 2++3 2+++3 445 677' Напишите регулярку, которая найдет строки '23', '2+3', '2++3', '2+++3', не захватив остальные.

'''
txt = '23 2+3 2++3 2+++3 445 677'
print(txt)
#txt = re.sub('2\\+*3', '!', txt)
print(txt)
'''

# 5 Дана строка:txt = '*+ *q+ *qq+ *qqq+ *qqq qqq+' Напишите регулярку, которая найдет строки '*q+', '*qq+', '*qqq+', не захватив остальные.

'''
txt = '*+ *q+ *qq+ *qqq+ *qqq qqq+'
print(txt)
txt = re.sub('\\*q+\\+', '!', txt)
print(txt)
'''

# 6

# Дана строка: txt = '[abc] {abc} abc (abc) [abc]' Напишите регулярку, которая найдет строки в квадратных скобках и заменит их на '!'.

'''
txt = '[abc] {abc} abc (abc) [abc]'
print(txt)
txt = re.sub('\\[...\\]', '!', txt)
print(txt)
'''

        # 37

        # Фигурные скобки в регулярных выражениях

        # Операторы '+', '*', '?' хороши, однако, с их помощью нельзя указать конкретное число повторений. В этом случае вам на помощь придет оператор {}.

        # Работает он следующим образом: {5} - пять повторений, {2,5} – повторяется от двух до пяти (оба включительно), {2,} - повторяется два и более раз. Посмотрите примеры:


# В данном примере шаблон поиска выглядит так: буква 'x', буква 'a' один или два раза, буква 'x':
'''
txt = 'xx xax xaax xaaax'
res = re.sub('xa{1,2}x', '!', txt)

print(res)
'''


# В данном примере шаблон поиска выглядит так: буква 'x', буква 'a' два раза и более, буква 'x':

'''
txt = 'xx xax xaax xaaax'
res = re.sub('xa{2,}x', '!', txt)

print(res)
'''

# В данном примере шаблон поиска выглядит так: буква 'x', буква 'a' три раза, буква 'x':

'''
txt = 'xx xax xaax xaaax'
res = re.sub('xa{3}x', '!', txt)

print(res)
'''


# В данном примере шаблон поиска выглядит так: буква 'a' десять раз:

'''
txt = 'aaa aaaaaaaaaa aaa'
res = re.sub('a{10}', '!', txt)

print(txt)
print(res)
'''

# В данном примере есть такой шаблон: буква 'x', буква 'a' три раза раза и меньше, буква 'x'. Для того, чтобы его реализовать, перед цифрой 3 можно не указывать число, а поставить просто запятую:

'''
txt = 'xx xax xaax xaaax'
res = re.sub('xa{,3}x', '!', txt)

print(txt)
print(res)
'''

# Ноль перед 3 тоже допустим:

'''
txt = 'xx xax xaax xaaax'
res = re.sub('xa{0,3}x', '!', txt)

print(txt)
print(res)
'''


# 1

# Дана строка: txt = 'aa aba abba abbba abbbba abbbbba' Напишите регулярку, которая найдет строки 'abba', 'abbba', 'abbbba' и только их.

'''
txt = 'aa aba abba abbba abbbba abbbbba'
res = re.sub('ab{2,4}a', '!', txt)

print(txt)
print(res)
'''


# 2

# Дана строка: txt = 'aa aba abba abbba abbbba abbbbba' Напишите регулярку, которая найдет строки вида 'aba', в которых 'b' встречается менее 3-х раз (включительно).

'''
txt = 'aa aba abba abbba abbbba abbbbba'
res = re.sub('ab{,3}a', '!', txt)

print(txt)
print(res)
'''

# 3 

# Дана строка: txt = 'aa aba abba abbba abbbba abbbbba' Напишите регулярку, которая найдет строки вида 'aba', в которых 'b' встречается более 4-х раз (включительно).

'''
txt = 'aa aba abba abbba abbbba abbbbba'
res = re.sub('ab{4,}a', '!', txt)

print(txt)
print(res)
'''


            # 38

            # Ограничение жадности в регулярках в Python

        # Регулярные выражения по умолчанию жадные. Это значит, что они захватывают максимальное возможное количество символов. Давайте разберем на примере. Пусть у нас есть вот такая строка:


#txt = 'aeeex zzz x kkk'

        # В этой строке хотим найти подстроку 'aeeex' по следующему шаблону: буква 'a', затем любой символ один или более раз, затем буква 'x':

#res = re.sub('a.+x', '!', txt)
#print(res)

        # Хотя нам нужно получить строку '! zzz x kkk', выведется строка '! kkk'. Все дело в том, что наша регулярка ищет все символы от буквы 'a' до буквы 'x'. Но в нашей строке две буквы 'x'! Из-за жадности получается, что регулярка ищет до самого последнего икса, тем самым захватывая не то, что нам было нужно.

        # Конечно, зачастую такое поведение нам и требуется. Но конкретно в этом случае нужно отменить жадность и сказать регулярке, чтобы она искала до первого икса. В этом случае следует после оператора повторения поставить знак вопроса:

#txt = 'aeeex zzz x kkk'

#res = re.sub('a.+?x', '!', txt)
#print(res)

        # Жадность можно ограничивать всем операторам повторения: и *, и ?, и {} - вот так: *?, ?? и {}?.

    # 1

# Дана строка: txt = 'aba accca azzza wwwwa' Напишите регулярку, которая найдет все строки по краям которых стоят буквы 'a', и заменит каждую из них на '!'. Между буквами 'a' может быть любой символ (кроме 'a').

'''
txt = 'aba accca azzza wwwwa'
res = re.sub('a.+?a', '!', txt)
print(res)
'''

            # 39

            # Группы символов в регулярных выражениях Python

        # Существуют специальные команды, которые позволяют выбрать сразу целые группы символов. Команда \d означает цифру от 0 до 9. Команда \w обозначает цифру, латинскую букву или знак подчеркивания. Команда \s обозначает пробел или пробельный символ: пробел, перевод строки, табуляцию. Можно инвертировать значение команды, написав большую букву: например, если \d - цифра, то \D - не цифра.

        # Пример 1

'''
txt = '1 12 123'
res = re.sub('\\d', '!', txt)
print(res)
'''

        # Пример 2

    # Операторы повторения считают команды-группы одним целым, то есть группирующие скобки не нужны. В следующем примере шаблон поиска выглядит так: цифра от 0 до 9 один или более раз:

'''
txt = '1 12 123 abc @@@'
res = re.sub('\\d+', '!', txt)
print(res)
'''

        # Пример 3

    # В следующем примере шаблон поиска выглядит так: все что угодно один или более раз, но не цифра от 0 до 9:

'''
txt = '123abc3@@'
res = re.sub('\\D+', '!', txt)
print(res)
'''

        # Пример 4

    # В данном примере шаблон поиска выглядит так: пробельный символ один раз:

'''
txt = '1 12 123 abc    @@'
res = re.sub('\\s', '!', txt)
print(res)
'''

        # Пример 5

    # В данном примере шаблон поиска выглядит так: НЕ пробельный символ один или более раз. Все подстроки, разделенные пробелами, заменятся на '!':

'''
txt = '1 12 123 abc    @@@'
res = re.sub('\\S+', '!', txt)
print(res)
'''

        # Пример 6

    # В данном примере шаблон поиска выглядит так: цифра или буква один или более раз. Все подстроки, состоящие из цифр и букв, заменятся на '!':

'''
txt = '1 12 123a Abc @@@'
res = re.sub('\\w+', '!', txt)
print(res)
'''

        # Пример 7

    # В данном примере шаблон поиска выглядит так: НЕ цифра и НЕ буква один или более раз. Под данное определение в нашем случае попадает '@@@' и все пробелы (они ведь тоже не цифры и не буквы). Обратите внимание на то, что в конце один '!' - в него преобразовалась строка ' @@@' - с пробелом впереди:

'''
txt = '1 12 123 Abc @@@'
res = re.sub('\\W+', '!', txt)
print(res)
'''

    # 1

# Дана строка: txt = 'a1a a2a a3a a4a a5a aba aca' Напишите регулярку, которая найдет строки, в которых по краям стоят буквы 'a', а между ними одна цифра.

'''
txt = 'a1a a2a a3a a4a a5a aba aca'
res = re.sub('a\\da', '!', txt)
print(res)
'''

    # 2

# Дана строка: txt = 'a1a a22a a333a a4444a a55555a aba aca' Напишите регулярку, которая найдет строки, в которых по краям стоят буквы 'a', а между ними любое количество цифр.

'''
txt = 'a1a a22a a333a a4444a a55555a aba aca'
res = re.sub('a\\d*a', '!', txt)
print(res)
'''

    # 3

# Дана строка: txt = 'aa a1a a22a a333a a4444a a55555a aba aca' Напишите регулярку, которая найдет строки, в которых по краям стоят буквы 'a', а между ними любое количество цифр (в том числе и ноль цифр, то есть строка 'aa').

'''
txt = 'aa a1a a22a a333a a4444a a55555a aba aca'
res = re.sub('a\\d*a', '!', txt)
print(res)
'''

    # 4

# Дана строка: txt = 'avb a1b a2b a3b a4b a5b abb acb' Напишите регулярку, которая найдет строки следующего вида: по краям стоят буквы 'a' и 'b', а между ними - не число и не пробел.

'''
txt = 'avb a1b a2b a3b a4b a5b abb acb'
res = re.sub('a[^0-9 ]b', '!', txt)
print(res)
'''

    # 5

# Дана строка: txt = 'ave a#b a2b a$b a4b a5b a-b acb' Напишите регулярку, которая найдет строки следующего вида: по краям стоят буквы 'a' и 'b', а между ними - не буква, не цифра и не пробел.

'''
txt = 'ave a#b a2b a$b a4b a5b a-b acb'
res = re.sub('a[^a-zA-Z0-9 ]b', '!', txt)
print(res)
'''

    # 6

# Дана строка: txt = 'ave a#a a2a a$a a4a a5a a-a aca' Напишите регулярку, которая заменит все пробелы на '!'.

'''
txt = 'ave a#a a2a a$a a4a a5a a-a aca'
#res = re.sub(' ', '!', txt)
res = re.sub('\\s', '!', txt)
print(res)
'''

            # 40

            # Наборы символов в регулярных выражениях Python

        # Группы символов \d и \w не очень гибкие. Даже такая простая задача, как найти все буквы, но не цифры - не может быть решена ими. Для таких задач следует использовать квадратные скобки, представляющие собой операцию 'или'.

        # Квадратные скобки заменяют собой один символ, любой из перечисленных внутри. К примеру, вот так: x[abc]x - мы говорим, что по краям должны стоять буквы икс, а внутри - один символ: или 'a', или 'b', или 'c'.

        # После квадратных скобок можно писать операторы повторения. К примеру, вот так: x[abc]+x - мы говорим, что внутри иксов может быть любое количество символов 'a', 'b' и 'c' - в любых комбинациях.

        # Можно не только перечислять символы, но создавать группы символов, записывая между двумя символами дефис. К примеру, вот так: [a-d] - мы получаем все символы от 'a' до 'd'.

        # Пример 1

    # В данном примере шаблон поиска выглядит так: между иксами любая буква от 'a' до 'z':

'''
txt = 'xax xbx xzx x@x'
res = re.sub('x[a-z]x', '!', txt)
print(res)
'''

        # Пример 2
    
    # В данном примере шаблон поиска выглядит так: между иксами любая буква от 'a' до 'k':

'''
txt = 'xax xbx xlx x@x'
res = re.sub('x[a-k]x', '!', txt)
print(res)
'''

        # Пример 3

    # В данном примере шаблон поиска выглядит так: между иксами любая буква от 'A' до 'Z':

'''
txt = 'xax xBx xcx xCx xXx xzx xZx xAx x@x'
res = re.sub('x[A-Z]x', '!', txt)
print(txt)
print(res)
'''

        # Пример 4

    # В данном примере шаблон поиска выглядит так: между иксами любая цифра от 0 до 9:

'''
txt = 'xax x0x x5x x9x x@x'
res = re.sub('x[0-9]x', '!', txt)
print(txt)
print(res)
'''

        # Пример 5

    # В данном примере шаблон поиска выглядит так: между иксами любая цифра от 3 до 7:

'''
txt = 'xax x1x x3x x5x x@x'
res = re.sub('x[3-7]x', '!', txt)
print(txt)
print(res)
'''

        # Пример 6

    # В данном примере шаблон поиска выглядит так: между иксами любая буква от 'a' до 'z' или цифра от 1 до 9:

'''
txt = 'xax x1x x3x x5x x@x'
res = re.sub('x[a-z1-9]x', '!', txt)
print(txt)
print(res)
'''

        # Пример 7

    # В данном примере шаблон поиска выглядит так: между иксами любая буква от 'a' до 'z' или буква от 'A' до 'Z':

'''
txt = 'xax xBx xcx x5x x@x'
res = re.sub('x[a-zA-Z]x', '!', txt)
print(txt)
print(res)
'''

        # Пример 8

    # В данном примере шаблон поиска выглядит так: между иксами любая буква от 'a' до 'z' или цифры 1, 2:

'''
txt = 'xax xbx x1x x2x x3x'
res = re.sub('x[a-z12]x', '!', txt)
print(txt)
print(res)
'''

        # Пример 9

    # В данном примере шаблон поиска выглядит так: между иксами буквы от 'a' до 'z' в количестве от 1 и более:

'''
txt = 'xx xabesx xaadx x123x xa3x'
res = re.sub('x[a-z]+x', '!', txt)
print(txt)
print(res)
'''

        # Пример 10

    # Сделаем так, чтобы количество букв могло быть и ноль:

'''
txt = 'xx xabesx xaadx x123x xa3x'
res = re.sub('x[a-z]*x', '!', txt)
print(txt)
print(res)
'''

        # Пример 11

    # Внутри квадратных скобок также можно указывать экранированные символы. Давайте найдем последовательность букв и цифр, повторяющуюся ноль или более раз:

'''
txt = 'xx x@x xadx xas12x xa3x'
res = re.sub('x[a-z\\d]*x', '!', txt)
print(txt)
print(res)
'''

        # Пример 12

    # Если же нам нужно указать еще одни квадратные скобки, то мы их тоже обязательно экранируем:

'''
txt = 'xx x[]x xrx xas[]x x3x'
res = re.sub('x[a-z\\[\\]]*x', '!', txt)
print(txt)
print(res)
'''

        # Практические задачи

    # 1

#Дана строка: txt = 'aba aea aca aza axa' Напишите регулярку, которая найдет по следующему шаблону: по краям стоят буквы 'a', а между ними - буква 'b', 'e' или 'x'.

'''
txt = 'aba aea aca aza axa'
res = re.sub('a[bex]a', '!', txt)
print(txt)
print(res)
'''

    # 2

# Дана строка: txt = 'a1a a3a a7a a9a aba' Напишите регулярку, которая найдет по следующему шаблону: по краям стоят буквы 'a', а между ними - цифра от 3-х до 6-ти.

'''
txt = 'a1a a3a a7a a9a aba'
res = re.sub('a[3-7]a', '!', txt)
print(txt)
print(res)
'''

    # 3

# Дана строка: txt = 'aba aea afa aha aga' Напишите регулярку, которая найдет по следующему шаблону: по краям стоят буквы 'a', а между ними - буква от 'a' до 'g'.

'''
txt = 'aba aea afa aha aga'
res = re.sub('a[a-g]a', '!', txt)
print(txt)
print(res)
'''

    # 4

# Дана строка: txt = 'aba aea afa aha aga' Напишите регулярку, которая найдет по следующему шаблону: по краям стоят буквы 'a', а между ними - буква от 'a' до 'f' и от 'j' до 'z'.

'''
txt = 'aba aea afa aha aga aia aka aqa aza'
res = re.sub('a[a-fj-z]a', '!', txt)
print(txt)
print(res)
'''

    # 5

# Дана строка: txt = 'aAa aea aEa aJa a3a' Напишите регулярку, которая найдет по следующему шаблону: по краям стоят буквы 'a', а между ними - буква от 'a' до 'f' и от 'A' до 'D'.

'''
txt = 'aAa aea aEa aJa a3a'
res = re.sub('a[a-fA-D]a', '!', txt)
print(txt)
print(res)
'''

    # 6 

# Дана строка: txt = 'aAXa aeffa aGha aza ax23a a3sSa' Напишите регулярку, которая найдет по следующему шаблону: по краям стоят буквы 'a', а между ними - маленькие латинские буквы, не затронув остальных.

'''
txt = 'aAXa aeffa aGha aza ax23a a3sSa'
res= re.sub('a[a-z]*a', '!', txt)
print(txt)
print(res)
'''

    # 7

# Дана строка: txt = 'aAXa aeffa aGha aza ax23a a3sSa' Напишите регулярку, которая найдет по следующему шаблону: по краям стоят буквы 'a', а между ними - маленькие и большие латинские буквы, не затронув остальных.

'''
txt = 'aAXa aeffa aGha aza ax23a a3sSa'
res = re.sub('a[a-zA-Z]*a', '!', txt)
print(txt)
print(res)
'''

    # 8

# Дана строка: txt = 'aAXa aeffa aGha aza ax23a a3sSa' Напишите регулярку, которая найдет по следующему шаблону: по краям стоят буквы 'a', а между ними - маленькие латинские буквы и цифры, не затронув остальных.

'''
txt = 'aAXa aeffa aGha aza ax23a a3sSa'
res = re.sub('a[a-z\\d]*a', '!', txt)
print(txt)
print(res)
'''

            # 41

            # Инвертирование наборов символов в регулярках

        # С помощью шляпки '^' в начале квадратных скобок можно инвертировать желаемое. Если, к примеру, команда [ab] ищет букву 'a' или 'b', то команда [^ab] будет искать все символы, кроме 'a' и 'b'.

        # Пример 1

    # В данном примере шаблон поиска выглядит так: буква 'x', затем НЕ буква 'a', не 'b' и не 'c', потом буква 'z':

'''
txt = 'xaz xbz xcz xez'
res = re.sub('x[^abc]z', '!', txt)
print(txt)
print(res)
'''

        # Пример 2

    # В данном примере шаблон поиска выглядит так: буква 'x', затем НЕ маленькая латинская буква, потом буква 'z':

'''
txt = 'xaz xbz x1z xСz'
res = re.sub('x[^a-z]z', '!', txt)
print(txt)
print(res)
'''

        # Практические задачи

    # 1

# Напишите регулярку, которая найдет строки по шаблону: цифра 1, затем символ не 'e' и не 'x', цифра 2.

'''
txt = '1x2 1e2 1E2 1X2 132 1@2 1x2 1e2'
res = re.sub('1[^ex]2', '!', txt)
print(txt)
print(res)
'''

    # 2

# Напишите регулярку, которая найдет строки по шаблону: буква 'x', затем НЕ цифра от 2 до 7, буква 'z'.

'''
txt = 'x2z x7z x1z x8z xsz x@z x7z x2z'
res = re.sub('x[^2-7]z', '!', txt)
print(txt)
print(res)
'''

    # 3

# Напишите регулярку, которая найдет строки по шаблону: буква 'x', затем НЕ большая латинская буква от 1 и более раз, буква 'z'.

'''
txt = 'xAz xaz xAz x2z xAz x@z xAz xqweqrwwqz  xqwezz xB2C3Dz xqw12@!xszz xV@A2A$Fx'
res = re.sub('x[^A-Z]+?z+', '!', txt)
print(txt)
print(res)
'''

    # 4

# Напишите регулярку, которая найдет строки по шаблону: буква 'x', затем НЕ большая или маленькая латинская буква и не цифра от 1 до 5 от 1 и более раз, буква 'z'.

'''
txt = 'xAz xaz x1z x6z xA@AZz x@z x23z x67890z x@Zz'
res = re.sub('x[^A-Z1-5]+?z+', '!', txt)
print(txt)
print(res)
'''

            # 42

            # Oсобенности кириллицы в регулярках Python

        # Большим преимуществом регулярок в Python является то, что кириллические символы входят в группу \w. Давайте заменим все латинские и кириллические буквы в следующей строке:

'''
txt = 'x232x 456 xax xтекстx'
res = re.sub('x[\\w]*x', '!', txt)
print(txt)
print(res)
'''

        # Также кириллические буквы можно искать с помощью группы в квадратных скобках: [а-я]. Но с ней есть проблема - сюда не войдет буква 'ё'. Для ее включения нужно дописать эту букву к группе:

'''
txt = 'x232x 456 хbёх хётекстх'
res = re.sub('х[а-яё]*х', '!', txt)
print(txt)
print(res)
'''


    # 1

# Дана строка: txt = 'wйw wяw wёw wqw' Напишите регулярку, которая найдет строки по шаблону: по краям стоят буквы 'w', а между ними - буква кириллицы.

'''
txt = 'wйw wяw wёw wqw'
res = re.sub('w[а-яё]+w', '!', txt)
print(txt)
print(res)
'''

    # 2

# Дана строка: txt = 'ааа ббб ёёё ззз ййй ААА БББ ЁЁЁ ЗЗЗ ЙЙЙ' Напишите регулярку, которая найдет все слова по шаблону: любая кириллическая буква любое количество раз.

'''
txt = 'ааа ббб ёёё ззз ййй ААА БББ ЁЁЁ ЗЗЗ ЙЙЙ'
res = re.sub('[а-яёА-ЯЁ]+', '!', txt)
print(txt)
print(res)
'''

            # 43

            # Спецсимволы внутри квадратных скобок в Python

        # Спецсимволы внутри [ ] становятся обычными символами. Это значит, что их не надо экранировать обратным слешем.

        # Пример 1

    # В данном примере шаблон поиска выглядит так: между иксами любая буква 'a', 'b', 'c', либо точка:

'''
txt = 'xax xbx xcx xdx x.x x@x'
res = re.sub('x[abc.]x', '!', txt)
print(txt)
print(res)
'''

        # Пример 2

    # В данном примере шаблон поиска выглядит так: между иксами любая маленькая латинская буква или точка:

'''
txt = 'xax xbx xcx x@x'
res = re.sub('x[a-z.]x', '!', txt)
print(txt)
print(res)
'''


    # 1

# Дана строка: txt = 'aba aea aca aza axa a.a a+a a*a' Напишите регулярку, которая найдет строки 'a.a', 'a+a', 'a*a', не затронув остальных.

'''
txt = 'aba aea aca aza axa a.a a+a a*a'
res = re.sub('a[\\.\\+\\*]a', '!', txt)
print(txt)
print(res)
'''

    # 2

# Дана строка: txt = 'xaz x.z x3z x@z x$z xrz Напишите регулярку, которая найдет строки по шаблону: буква 'x', затем НЕ точка, НЕ собака, и НЕ доллар, а потом буква 'z'.

'''
txt = 'xaz x.z x3z x@z x$z xrz x(z'
res = re.sub('x[^\\.\\$\\(]z', '!', txt)
print(txt)
print(res)
'''

            # 44

            # Группы символов внутри наборов в регулярках Python

        # Группы символов \d, \D, \w, \W, \s, \S внутри [] будут обозначать именно группы, то есть по-прежнему будут командами.

        # Пример 1

    # В данном примере шаблон поиска выглядит так: между иксами любая цифра, либо буква от 'a' до 'f':

'''
txt = 'xax xbx x1x x2x xhx x@x'
res = re.sub('x[\\da-f]x', '!', txt)
print(txt)
print(res)
'''

        # Пример 2

    # В данном примере шаблон поиска выглядит так: буква 'x', затем не цифра, не точка, и не маленькая латинская буква, затем буква 'z':

'''
txt = 'xaz x1z xAz x.z x@z'
res = re.sub('x[^\\d.a-z]z', '!', txt)
print(txt)
print(res)
'''

    # 1

# Напишите регулярку, которая найдет строки по шаблону: цифра или точка от 1 и более раз.

'''
txt = 'a x 12 1.1.1 a1sd a.asd ... .1.1. @.@.@'
res = re.sub('[\\d.]+', '!', txt)
print(txt)
print(res)
'''

    # 2

# Напишите регулярку, которая найдет строки по шаблону: не цифра и не буква от 'a' до 'g' от 3 до 7 раз.

'''
txt = 'hh hhh ##@. #@># ##@@$$.. asdsa 43ad31 123.123 abc...abc ff ffff 1111'
res = re.sub('[^\\da-g{3, 7}]', '!', txt)
print(txt)
print(res)
'''

            # 45

            # Исключения внутри наборов в регулярках Python

            # Вы уже знаете, что спецсимволы внутри [] становятся обычными символами. Есть, однако, исключения: если вам нужны квадратные скобки как символы внутри [ ] - то их нужно экранировать обратным слешем. Для примера в следующем коде шаблон поиска выглядит так: между иксами стоит квадратная скобка:

'''
txt = 'x]x xax x[x x1x'
res = re.sub('x[\\[\\]]x', '!', txt)
print(txt)
print(res)
'''

    # 1

# Дана строка: txt = 'x[]z x[[]]z x()z' Напишите регулярку, которая найдет все слова по шаблону: буква 'x', затем квадратные скобки любое количество раз, затем буква 'z'.

'''
txt = 'x[]z x[[]]z x()z'
res = re.sub('x[\\[\\]]*z', '!', txt)
print(txt)
print(res)
'''

    # 2

# Дана строка: txt = 'x[]z x{}z x.z x()z x([])z' Напишите регулярку, которая найдет все слова по шаблону: буква 'x', затем любое количество любых скобок, затем буква 'z'.

'''
txt = 'x[]z x{}z x.z x()z x([])z'
res = re.sub('x[\\[\\]\\(\\)\\{\\}]*z', '!', txt)
print(txt)
print(res)
'''

            # 46

            # Символ шляпки внутри наборов в регулярках Python

        # Как вы знаете, шляпка внутри [ ] делает отрицание, будучи написанной в начале скобок. Значит, она является спецсимволом внутри этих скобок. Чтобы получить шляпку как символ, нужно или заэкранировать ее, или убрать с первого места.

        # Пример 1

'''
txt = 'axx bxx ^xx dxx'
res = re.sub('[^d]xx', '!', txt)
print(txt)
print(res)
'''

        # Пример 2

    # А теперь шаблон поиска такой: первый символ - это 'd' или '^', потом две буквы 'x':

'''
txt = 'axx bxx ^xx dxx'
res = re.sub('[d^]xx', '!', txt)
print(txt)
print(res)
'''

        # Пример 3

    # Можно не убирать шляпку с первого места, а просто заэкранировать ее с помощью обратного слеша, и она станет обозначать саму себя:

'''
txt = 'axx bxx ^xx dxx'
res = re.sub('[\\^d]xx', '!', txt)
print(txt)
print(res)
'''

    # 1

# Дана строка: txt = '^xx axx ^zz bkk @ss' Напишите регулярку, которая найдет строки по шаблону: шляпка или собака, а затем две латинских буквы.

'''
txt = '^xx axx ^zz bkk @ss'
res = re.sub('[@^][a-zA-Z]{2}', '!', txt)
#res = re.sub('[@^][a-zA-Z][a-zA-Z]', '!', txt)
print(txt)
print(res)
'''

    # 2

# Дана строка: txt = '^xx axx ^zz bkk @ss' Напишите регулярку, которая найдет строки по шаблону: НЕ шляпка и не собака, а затем две латинских буквы.

'''
txt = '^xx axx ^zz bkk @ss'
res = re.sub('[^\\s\\^\\@][a-zA-Z]{2}', '!', txt)
print(txt)
print(res)
'''

    # 3

# Дана строка: txt = '^xx axx ^zz bkk' Напишите регулярку, которая найдет строки по шаблону: не шляпка и не пробел, а затем две латинских буквы.

'''
txt = '^xx axx ^zz bkk'
res = re.sub('[^\\^\\s][a-zA-Z]{2}', '!', txt)
print(txt)
print(res)
'''

            # 47

            # Дефис внутри наборов в регулярках Python

        # Дефис - тоже спецсимвол внутри [ ] (а вот снаружи - нет). Если вам нужен сам дефис как символ - то поставьте его там, где он не будет воспринят как разделитель группы.

        # Почему это важно: вы можете сделать группу символов, сами не заметив этого. К примеру, вот так - '[:-@]' - вы думаете, что выбираете двоеточие, дефис и собаку, а на самом деле получается группа символов между : и @. В эту группу входят следующие символы: ? < = > :

        # Откуда они взялись? Из таблицы ASCII - двоеточие имеет номер меньше, чем собака - и получается группа. То есть все группы получаются по таблице ASCII (при желании этим можно пользоваться).

        # Как с этим бороться: поставьте символ дефиса там, где он точно не будет воспринят как символ группы, например, в начале или в конце (то есть после [или перед ]).

        # Можно также заэкранировать дефис - тогда он будет обозначать сам себя независимо от позиции. Например, вместо [:-@] написать [:\-@] - и группы уже не будет, а будут три символа - двоеточие, дефис и собака @.


        # Пример 1

    # В следующем примере шаблон поиска такой: цифра 1, затем буква от 'a' до 'z', затем цифра 2:

'''
txt = '1a2 1-2 1c2 1z2'
res = re.sub('1[a-z]2', '!', txt)
print(txt)
print(res)
'''

        # Пример 2

    # Давайте теперь заэкранируем дефис. В результате шаблон поиска такой: цифра 1, затем буква 'a', или дефис, или буква 'z', затем цифра 2:

'''
txt = '1a2 1-2 1c2 1z2'
res = re.sub('1[a\\-z]2', '!', txt)
print(txt)
print(res)
'''

        # Пример 3

    # Можно просто переставить дефис, не экранируя его:

'''
txt = '1a2 1-2 1c2 1z2'
res = re.sub('1[az-]2', '!', txt)
print(txt)
print(res)
'''

        # Пример 4

    # В следующем примере шаблон поиска такой: первый символ - это маленькие буквы или дефис '-', потом две буквы 'x':

'''
txt = 'axx Axx -xx @xx'
res = re.sub('[a-z-]xx', '!', txt)
print(txt)
print(res)
'''

        # Пример 5

    # В следующем примере шаблон поиска такой: первый символ - это маленькие, большие буквы или дефис '-', потом две буквы 'x':
'''
txt = 'axx Axx -xx @xx'
res = re.sub('[a-zA-Z-]xx', '!', txt)
print(txt)
print(res)
'''

        # Пример 6

    # Можно расположить дефис между двумя группами - там он точно еще не сделает еще одну группу:

'''
txt = 'axx 9xx -xx @xx'
res = re.sub('[a-z-0-9]xx', '!', txt)
print(txt)
print(res)
'''

    # 1

# Дана строка: txt = 'xaz xBz xcz x-z x@z' Найдите все строки по следующему шаблону: буква 'x', большая или маленькая буква или дефис, буква 'z'.

'''
txt = 'xaz xBz xcz x-z x@z'
res = re.sub('x[a-zA-Z-]z', '!', txt)
print(txt)
print(res)
'''

    # 2

# Дана строка: txt = 'xaz x$z x-z xcz x+z x%z x*z' Найдите все строки по следующему шаблону: буква 'x', затем или доллар, или дефис или плюс, потом буква 'z'.

'''
txt = 'xaz x$z x-z xcz x+z x%z x*z'
res = re.sub('x[-$+]z', '!', txt)
print(txt)
print(res)
'''

            # 48

            # Начало и конец строки в регулярках Python

        # Пример 1

    # В данном примере шаблон поиска такой: заменить 'aaa' на '!' только, если оно стоит в начале строки:

'''
txt = 'aaa aaa aaa'
res = re.sub('^aaa', '!', txt)
print(txt)
print(res)
'''

        # Пример 2

    # В данном примере шаблон поиска такой: заменить 'aaa' на '!' только, если оно стоит в конце строки:

'''
txt = 'aaa aaa aaa'
res = re.sub('aaa$', '!', txt)
print(txt)
print(res)
'''

        # Пример 3

    # Когда в начале регулярки стоит '^', а в конце - '$', то таким образом проверяется вся строка целиком на соответствие регулярке.

    # В следующем примере шаблон поиска такой: буква 'a' повторяется один или более раз, заменить всю строку на '!' только она состоит из одних букв 'a':

'''
txt = 'aaa'
res = re.sub('a+$', '!', txt)
print(txt)
print(res)
'''

    # 1

# Дана строка: txt = 'abc def xyz' Напишите регулярку, которая найдет первую подстроку из букв.

'''
txt = 'abc def xyz'
res = re.sub('^...', '!', txt)
print(txt)
print(res)
'''

    # 2

# Дана строка: txt = 'abc def xyz' Напишите регулярку, которая найдет последнюю подстроку из букв.

'''
txt = 'abc def xyz'
res = re.sub('...$', '!', txt)
print(txt)
print(res)
'''

            # 49

            # Границы слов в регулярках Python

        # С помощью команды '\\b' можно обратиться к границе слова, а с помощью команды '\B' или '\\B' - не к границе. Обратите внимание на то, что в случае определения границы слов в Python работает экранирование строго с помощью двух слешей, хотя для других команд допускается один слеш. Давайте посмотрим работу этих команд на примерах.

        # Пример 1

    # Давайте обернем каждое слово в символ '!':

'''
txt = 'aaa aaa aaa'
print(re.sub('\\b', '!', txt))
'''

        # Пример 2

    # Давайте добавим символ '!' в промежутки между буквами:

'''
txt = 'aaa aaa aaa'
print(re.sub('\\B', '!', txt))
'''

    # 1

# Дана строка: txt = 'abc def xyz' Напишите регулярку, которая сделает из этой строки следующую: '#abc# #def# #xyz#'

'''
txt = 'abc def xyz'
print(re.sub('\\b', '#', txt))
'''

    # 2

# Дана строка: txt = 'abc def xyz' Напишите регулярку, которая сделает из этой строки следующую: 'a+b+c d+e+f x+y+z'

'''
txt = 'abc def xyz'
print(re.sub('\\B', '+', txt))
'''

            # 50

            # Многострочность в регулярках Python

        # Регулярки при работе с многострочными строками имеют свои особенности. Давайте с ними разбираться на примере следующей строки, содержащей обычные символы, символы перевода строк и табуляции:
"""
txt = '''
    111
    222
    333
    444
'''
"""
        # Перевод строки

    # Символы перевода строки можно поймать с помощью команды '\n':
'''
res = re.sub('\\n', '!', txt)
print(txt)
print(res)
'''

        # Табуляция

    # Символы табуляции можно поймать с помощью команды '\t':

'''
res = re.sub('\\t', '!', txt)
print(txt)
print(res)
'''

        # Работа точки

    # Команда '.' для многострочной строки не ловит символы перевода строки:

'''
res = re.sub('.', '!', txt)
print(txt)
print(res)
'''

        # Команда '.' для многострочной строки не ловит символы перевода строки:

    # Чтобы поймать все символы в многострочной строке, используется хитрый прием в виде сочетания [\s\S]. Такая конструкция найдет все обычные символы и все переводы строк:

'''
res = re.sub('[\\s\\S]', '!', txt)
print(txt)
print(res)
'''

        # Доллар

    # Команда '$' в многострочном режиме будет ловить конец каждой строки:

'''
res = re.sub('$', '!', txt)
print(txt)
print(res)
'''

    # 1

# Дана строка:

'''
	abc
	def
	ghi
	jkl
'''
# Напишите регулярку, которая сделает из этой строки следующую:

'''
	abc!
	def!
	ghi!
	jkl!
'''

"""
txt = '''    abc
    def
    ghi
    jkl'''
res = re.sub('$', '!', txt, flags=re.MULTILINE)
print(res)
"""

    # 2

# Дана строка:

'''
    abc
    def
    ghi
    jkl
'''
# Напишите регулярку, которая сделает из этой строки следующую:

'''
!	abc
!	def
!	ghi
!	jkl
'''

"""
txt = '''    abc
    def
    ghi
    jkl'''

res = re.sub('^', '!', txt, flags=re.MULTILINE)
print(txt)
print(' ')
print(res)
"""

    # 3 

# Дана строка:

'''
    abc
    def
    ghi
    jkl
'''
# Напишите регулярку, которая сделает из этой строки следующую:

'''!
    abc
    def
    ghi
    jkl
!'''

"""
txt = '''
    abc
    def
    ghi
    jkl
'''
res = re.sub('\\Z', '!', txt, flags=re.DEBUG)
res = re.sub('\\A', '!', res)
print((res))
"""

    # 4

# Дана строка:

'''
	abc
	def
	ghi
	jkl
'''

# Напишите регулярку, которая сделает из этой строки следующую:

'''!
!	abc
!	def
!	ghi
!	jkl
!'''

"""
txt = '''
    abc
    def
    ghi
    jkl
'''
res = re.sub('^', '!', txt, flags=re.MULTILINE)
print(res)
"""

    # 5

# Дана строка:

'''
	abc
	def
	ghi
	jkl
'''

# Напишите регулярку, которая сделает из этой строки следующую:

'''!
	abc!
	def!
	ghi!
	jkl!
!'''

"""
txt = '''
    abc
    def
    ghi
    jkl
'''
res = re.sub('$', '!', txt, flags=re.MULTILINE)
print(res)
"""

    # 6

# Дана строка:

'''
	abc
	def
	ghi
	jkl
'''

# Напишите регулярку, которая сделает из этой строки следующую:

'''
	!abc
	!def
	!ghi
	!jkl
'''

"""
txt = '''
    abc
    def
    ghi
    jkl
'''
res = re.sub(r'^(\\s*)',
    r'\1!',
    txt,
    flags=re.MULTILINE)
print(res)
"""

            # 51

            # Команда 'или' в регулярных выражениях Python

        # Команда '|', которая представляет собой более мощный вариант 'или' по сравнению с командой [ ]. Данная команда позволяет разделить регулярку на несколько частей. При этом искомое может попасть либо под одну часть регулярки, либо под другую. Давайте посмотрим на примерах.

        # Пример 1

    # В данном примере шаблон поиска такой: три буквы 'a' или три буквы 'b':

'''
txt = 'aaa bbb abb'
res = re.sub('a{3}|b{3}', '!', txt)
print(res)
'''

        # Пример 2

    # В данном примере шаблон поиска такой: три буквы 'a' или от 1 и более букв 'b':

'''
txt = 'aaa bbb bbbb bbbbb axx'
res = re.sub('a{3}|b+', '!', txt)
print(res)
'''

        # Пример 3

    # В данном примере шаблон поиска такой: одна или более буквы или три цифры:

'''
txt = 'a ab abc 1 12 123'
res = re.sub('[a-z]+|\\d{3}', '!', txt)
print(res)
'''

        # Пример 4

    # Вертикальная черта может делить регулярку не на две части, а на любое количество частей:

'''
txt = 'aaa bbb ccc ddd'
res = re.sub('a+|b+|c+', '!', txt)
print(res)
'''

        # Пример 5

    # Если вертикальная черта стоит внутри круглых скобок, то 'или' работает только внутри этих скобок.

    # Для примера давайте найдем строки по следующему шаблону: в начале стоит или 'a', или 'b' один или более раз, а потом две буквы 'x':

'''
txt = 'axx bxx bbxx exx'
res = re.sub('(a|b+)xx', '!', txt)
print(res)
'''

    # 1

# Дана строка: txt = 'aeeea aeea aea axa axxa axxxa' Напишите регулярку, которая найдет строки по шаблону: по краям стоят буквы 'a', а между ними - или буква 'e' любое количество раз или буква 'x' любое количество раз.

'''
txt = 'aeeea aeea aea axa axxa axxxa'
res = re.sub('a(e*|x*)a', '!', txt)
print(res)
'''

    # 2

# Дана строка: txt = 'aeeea aeea aea axa axxa axxxa' Напишите регулярку, которая найдет строки по шаблону: по краям стоят буквы 'a', а между ними - или буква 'e' два раза или буква 'x' любое количество раз.

'''
txt = 'aeeea aeea aea axa axxa axxxa'
res = re.sub('a(e{2}|x*)a', '!', txt)
print(res)
'''

            # 52

            # Метод search в регулярных выражениях Python

        # В предыдущих уроках мы изучали регулярки с помощью метода для поиска и замены. Существуют и другие методы. В данном уроке мы начнем их изучать.

        # Новый метод, который мы изучим, называется search. Он ищет первое совпадение с регуляркой в строке. В первом параметре метода нужно указать регулярку, которую будем искать, во втором параметре - строку, в которой ее ищем. Метод проверяет совпадения, проходя по строке слева направо.

        # Своим результатом метод возвращает специальный match-объект, содержащий информацию о найденной подстроке и ее расположении в исходной строке.

        # Давайте попробуем на практике. Найдем первую подстроку с цифрами с помощью метода search:

'''
txt = 'aaa 123 bbb 456'
res = re.search('\\d+', txt)
print(res)
        # А теперь выведем найденный текст. Он попадет попадает в нулевой элемент match-объекта:
print(res[0])
'''

    # 1

# Дана строка: txt = '123 abc 456 cde' Найдите первую подстроку, содержащую только буквенные символы. Выведите ее в консоль.

'''
txt = '123 abc 456 cde'
res = re.search('[a-zA-Zа-яА-ЯёЁ]+', txt)
print(res)
print(res[0])
'''

    # 2

# Дана строка: txt = '1 23 456 789' Найдите позицию первого числа, состоящего из трех цифр.

'''
txt = '1 23 456 789'
res = re.search('[0-9]{3}', txt)
print(res)
print(res[0])
'''

            # 53

            # Позиция найденного в методе search Python

        # С помощью match-объекта можно также определить позицию найденной подстроки. Для этой цели применяются два метода. Метод start возвращает позицию начала, а метод end - позицию конца.

        # Давайте попробуем на практике. Пусть у нас есть строка:

'''
txt = '123 456 789'

        # Давайте найдем в ней первую подстроку с цифрами через метод search, а затем выведем позицию полученной подстроки с помощью методов start и end:

res = re.search('\\d+', txt)
print(res)
print(res[0])
print(res.start())
print(res.end())
'''

    # 1
 
# Дана строка: txt = 'abcde 123456' Найдите в ней подстроку, состоящую только из букв. Выведите позицию начала и конца найденной подстроки.

'''
txt = 'abcde 123456'
res = re.search('\\w+', txt)
print(res)
print(res[0])
print(res.start())
print(res.end())
'''

            # 54

            # Карманы в методе search Python

        # Часто при поиске совпадения удобно разложить подстроку на так называемые карманы. Они представляют собой способ разбить найденное на отдельные части. Для их использования нужно заключить часть регулярки в круглые скобки.

        # Давайте попробуем на практике. Пусть у нас есть следующая строка:

'''
txt = '123 456'

        # Давайте разложим подстроки с числами по карманам. Для этого напишем следующую регулярку:

res = re.search('(\\d+) (\\d+)', txt)

        # В результате мы получим match-объект. В его элементе с индексом 1 будет лежать первый карман, в элементе с индексом 2 - второй карман, а в элементе с индексом 0 - все найденное (так называемый нулевой карман):


print(res)
print(res[0])
print(res[1])
print(res[2])
'''

    # 1

# Дана строка, содержащая домен: txt = 'sss domain.ru zzz' Найдите этот домен и положите его имя в первый карман, а зону - во второй.

'''
txt = 'sss domain.ru zzz'
res = re.search('([a-z]+)(\\.[a-z]+)', txt)
print(res)
print(res[0])
print(res[1])
print(res[2])
'''

    # 2

# Дана строка, содержащая дату: txt = '31.12.2025' Положите день в первый карман, месяц - во второй, а год - в третий.

'''
txt = '31.12.2025'
res = re.search('(\\d+)\\.(\\d+)\\.(\\d+)', txt)
print(res)
print(res[0])
print(res[1])
print(res[2])
print(res[3])
'''

            # 55

            # Карманы через метод group в методе search Python

        # Альтернативным способом работы с карманами является использование метода group. В его параметре указывается номер кармана, который нужно вывести. Если в параметре указать 0 или оставить его пустым, то вернется вся подстрока, совпадающая с регуляркой.

        # Пусть у нас есть строка:

'''
txt = '123 456 789'


        # Давайте выведем из нее первое совпадение с цифрами, заданными регуляркой метода search. А затем положим подстроку в три кармана, каждый из которых выведем методом group:

res = re.search('(\\d+)(\\d+)(\\d+)', txt)
print(res)
print('')
print(res[0])
print(res.group(0))
print('')
print(res[1])
print(res.group(1))
print('')
print(res[2])
print(res.group(2))
print('')
print(res[3])
print(res.group(3))
'''

    # 1

# Дана строка: txt = 'username:john' Положите 'username:' в первый карман, а 'john' - во второй. Выведите все карманы в консоль.

'''
txt = 'username:john'
res = re.search('([a-zA-Zа-яА-ЯёЁ]+):([a-zA-Zа-яА-ЯёЁ]+)', txt)
print(res[0])
print(res.group(0))
print('')
print(res[1])
print(res.group(1))
print('')
print(res[2])
print(res.group(2))
'''

    # 2

# Дана строка: txt = '123 aaabbbccc' Разложите все буквенные символы по трем карманам так, чтобы подстрока, состоящая из буквы 'a' попала в первый карман, 'b' - во второй, 'c' - в третий. Выведите все карманы в консоль.

'''
txt = '123 aaabbbccc'
res = re.search('(a+)(b+)(c+)', txt)
print(res[0])
print(res.group(0))
print('')
print(res[1])
print(res.group(1))
print('')
print(res[2])
print(res.group(2))
print('')
print(res[3])
print(res.group(3))
'''

            # 56

            # Все карманы в виде кортежа в методе search Python

        # Можно получить все карманы в виде кортежа. Это делается с помощью метода groups.

        # Давайте посмотрим, как с ним работать. Пусть у нас есть строка:

'''
txt = '123 456 789'

        # Давайте найдем первую строку, совпадающую с цифрами. А затем выведем из нее все карманы в виде кортежа:

res = re.search('(\\d)(\\d)(\\d)', txt)
print(res.groups(), type(res.group(0)), type(res.groups()))
'''

    # 1

# Дана строка, содержащая домен: txt = 'http://domain.ru' Получите кортеж, состоящий из протокола, имени домена и доменной зоны.

'''
txt = 'http://domain.ru'
res = re.search('([a-zA-Zа-яА-ЯёЁ]+)://([a-zA-Zа-яА-ЯёЁ]+)\\.([a-zA-Zа-яА-ЯёЁ]+)', txt)
print(res.groups())
'''

            # 57

            # Именованные карманы в методе search Python

        # Чтобы сделать работу с карманами более удобной, можно задать им имена. Для этого в первом параметре метода search перед обозначением регулярки прописывается строка '?P', после нее в угловых скобках указывается имя кармана.

        # Такие карманы можно получить с помощью метода groupdict. Он выведет их в виде словаря, в котором ключ - имя кармана, а значение - подстрока, лежащая в нем.

        # Давайте рассмотрим работу с именованными карманами на примере. Пусть у нас есть строка:

'''
txt = '123 456'

        # Давайте сделаем для нее два кармана, которые будут называться 'num1' и 'num2' соответственно:

res = re.search('(?P<num1>\\d+)\\s(?P<num2>\\d+)', txt)
print(res.groupdict())
'''

    # 1

# Дана строка со временем: txt = '12:59:59' Положите часы, минуты и секунды в отдельные именованные карманы.

'''
txt = '12:59:59'
res = re.search('(?P<hours>\\d+):(?P<minutes>\\d+):(?P<seconds>\\d+)', txt)
print(res.groupdict())
'''

    # 2

# Дана строка: txt = 'aaa bbb 123 456' Положите подстроки 'aaa' и 'bbb' в отдельные именованные карманы.

'''
txt = 'aaa bbb 123 456'
res = re.search('(?P<let_a>a+)\\s(?P<let_b>b+)', txt)
print(res.groupdict())
'''

    # 3

# Дана строка: txt = 'alex23' Положите имя и возраст пользователя в отдельные именованные карманы.

'''
txt = 'alex23'
res = re.search('(?P<Name>[a-zA-Zа-яА-ЯёЁ]+)(?P<Age>\\d+)', txt)
print(res.groupdict())
'''

            # 58

            # Карманы в строке замены в Python

        # При работе с методом sub, если что-то нужно положить в карман в регулярке, то в строке замены можно вставить содержимое этого кармана написав двойной слеш \\ и номер кармана. Например, \\1 - первый карман, \\2 - второй карман и так далее.

        # Зачем это нужно и как этим пользоваться давайте посмотрим на примерах.

        # Пример 1

        # Давайте найдем все числа и вместо них вставим эти же числа, но в круглых скобках. Для этого все найденные числа заменим на них самих же, но в скобках:


'''
txt = '1 23 456 xax'
res = re.sub('(\\d+)', '(\\1),', txt)
print(res)
'''

        # Пример 2

        # Давайте найдем все строки, представляющие собой числа с иксами вокруг и заменим эти числа на них же, но с '!' знаками вокруг:

'''
txt = 'x1x x23x x456 xax'
res = re.sub('x(\\d+)x', '!\\1!', txt)
print(res)
'''

        # Пример 3

        # Давайте решим следующую задачу: дана строка 'aaa@bbb ссс@ddd' - буквы, потом собака, потом буквы. Нужно поменять местами буквы в подстроке 'aaa@bbb' до '@' и после:

'''
txt = 'aaa@bbb ссс@ddd'
res = re.sub('([a-z]+)@([a-z]+)', '\\2@\\1', txt)
print(txt)
print(res)
'''

    # 1

# Дана строка: txt = '12 34 56 78' Поменяйте местами цифры во всех двухзначных числах.

'''
txt = '12 34 56 78'
res = re.sub('([1-9]+)([1-9]+)', '\\2\\1', txt)
print(txt)
print(res)
'''

    # 2

# Дана строка с датой: txt = '31.12.2025' Преобразуйте эту дату в '2025.12.31'.

'''
txt = '31.12.2025'
res = re.sub('(\\d+).(\\d+).(\\d+)', '\\3.\\2.\\1', txt)
print(txt)
print(res)
'''

            # 59

            # Отмена экранирования номера кармана Python

        # Вместо того, чтобы писать двойной слеш, можно применить специальную команду r, которая указывается перед открытием одинарных кавычек.

        # Пусть у нас есть строка:
'''
txt = '1 23 456 xax'

        # Давайте найдем все числа и разместим их в круглые скобки. Для этого все найденные числа заменим на них самих же, но в скобках. А вместо двойного слеша используем команду r:

res = re.sub(r'(\\d+)', r'(\1)', txt)
print(txt)
print(res)
'''

    # 1

# Дана строка: txt = 'ab cd ef' Поменяйте местами буквы во всех двухзначных подстроках.

'''
txt = 'ab cd ef'
res = re.sub(r'(\\w)(\\w)', r'\2\1', txt)
print(txt)
print(res)
'''

    # 2

# Дана строка с датой: txt = '2025:12:31' Преобразуйте эту дату в '31-12-2025'.

'''
txt = '2025:12:31'
res = re.sub(r'(\\d+):(\\d+):(\\d+)', r'\3-\2-\1', txt)
print(txt)
print(res)
'''

            # 60

            # Для поиска всех совпадений с регуляркой в Python применяется метод findall. В первом параметре метода указываем регулярку, которую будем искать, во втором параметре - строку для поиска.

            # Метод проверяет все совпадения, ища их слева направо. Он возвращает список строк с совпадениями или список кортежей, если для поиска заданы регулярки в карманах.

            # Если совпадения не найдены, то вернется пустой список. Синтаксис метода findall выглядит так:

# re.findall(что искать, где искать)

        # Давайте найдем все совпадения с регуляркой в строке:

'''
txt = '12 45 56 ab'
res = re.findall(r'\\d+', txt)
print(res)
'''

    # 1

# Дана строка: txt = '123 aaa 456 bbb 789' Выведите список подстрок, содержащих цифры.

'''
txt = '123 aaa 456 bbb 789'
res = re.findall(r'\\d+', txt)
print(res)
'''

    # 2

#Дана строка: txt = 'abc 123 def 456 789' Выведите список подстрок, содержащих буквы.

'''
txt = 'abc 123 def 456 789'
res = re.findall(r'[a-zA-Zа-яА-ЯёЁ]+', txt)
print(res)
'''

            # 61

            # Карманы в методе findall Python

            # В методе findall можно задавать карманы для поиска совпадений.

        # Пусть у нас есть строка:
'''
txt = '12 43 56 ab'

        # Давайте найдем все пары чисел и разложим их по карманам:

res = re.findall(r'(\\d)(\\d)', txt)
print(res)
'''

    # 1

# Дана следующая строка: txt = '12:37 15:48 17:59'; Найдите в ней все подстроки с временем и для каждого найденного разложите часы и минуты по карманам.

'''
txt = '12:37 15:48 17:59'
res = re.findall(r'(\\d)(\\d)', txt)
print(res)
'''

    # 2

# Дана строка: txt = 'site.ru sss site.com zzz site.net'; Получите доменные имена из этой строки, положив имя домена и его зону в разные карманы.

'''
txt = 'site.ru sss site.com zzz site.net'
res = re.findall(r'(\\w+).(\\w+)', txt)
print(res)
'''

            # 62

            # Метод finditer в регулярных выражениях Python

        # Метод finditer предназначен для получения итератора всех совпадений с регуляркой в строке. В первом параметре метода указываем регулярку, которую будем искать, во втором параметре - строку, которой ищем. Метод проверяет все совпадения, ища их слева направо. Метод возвращает итератор объектов сопоставления. Синтаксис метод finditer выглядит так:

# re.finditer(что искать, где искать)

        # Давайте найдем все подстроки с цифрами в нашей строке:

"""
txt = 'aaaa 123 bbbb 456'
res = re.finditer('\\d+', txt)
print(res)

# Результат выполнения кода:
# <callable_iterator object at 0x000002AA891300A0>
'''
for el in res:
    print(el)
'''
# После выполнения кода выведется два match-объекта:
# <re.Match object; span=(5, 8), match='123'>
# <re.Match object; span=(14, 17), match='456'>

# Данные объекты содержат информацию о всех совпадениях с регуляркой в виде кортежа. Можно вывести из них совпадения по индексу:

for el in res:
    print(el[0])
"""

    # 1

# Дана строка: txt = '12 aaa 34 bbb 56 ccc' Выведите из нее все числа с помощью цикла.

'''
txt = '12 aaa 34 bbb 56 ccc'
res = re.finditer('(\\d+)', txt)
lst = []
for el in res:
    lst.append(el[0])
print(lst)
'''

            # 63

            # Карманы в методе finditer Python

        # В методе finditer также можно использовать карманы. Давайте посмотрим на практике. Пусть у нас есть строка:

'''
txt = 'aaaa 123 bbbb 456'

        # Давайте разместим все цифры, которые находятся в строке, по карманам. А при переборе объектов циклом выведем первое совпадение (оно будет считаться нулевым карманом), а также его элементы, тоже в свою очередь раскиданные по карманам:

res = re.finditer('(\\d)(\\d)', txt)
lst = []
for el in res:
    lst.append(el[0])
    lst.append(el[1])
    lst.append(el[2])
print(lst)
'''

    # 1

# Дана строка: txt = 'aaa 123 bbb 456 987' Раскидайте все подстроки с числами по трем карманам. И выведите их с помощью цикла.

'''
txt = 'aaa 123 bbb 456 987'
res = re.finditer('(\\d)(\\d)(\\d)', txt)
lst = []
for el in res:
    lst.append(el[0])
    lst.append(el[1])
    lst.append(el[2])
    lst.append(el[3])
print(lst)
'''

            # 64

            # Именованные карманы в методе finditer в Python

        # При применении метода finditer можно использовать именованные карманы:

'''
txt = 'aaaa 123 bbbb 456'
res = re.finditer('(?P<test1>\\d)(?P<test2>\\d)', txt)
lst = []
for el in res:
    lst.append(el[0])
    lst.append(el['test1'])
    lst.append(el['test2'])
print(lst)
'''

    # 1

# Дана строка: txt = '456 aaa 123 b2bb 987' Найдите все подстроки, содержащие только цифры, и раскиньте их по двум именованным карманам. Выведите их с помощью цикла.

'''
txt = '456 aaa 123 b2bb 987'
res = re.finditer('(?P<num1>\\d)(?P<num2>\\d)(?P<num3>\\d)', txt)
lst = []
for el in res:
    lst.append(el[0])
    lst.append(el['num1'])
    lst.append(el['num2'])
    lst.append(el['num3'])
print(lst)
'''

            # 65

            # Метод fullmatch в регулярных выражениях Python

            # Метод fullmatch проверяет строку на полное совпадение с регуляркой. В первом параметре метода указываем регулярку, которую будем искать, во втором параметре - строку, в которой ее ищем. 

            # Если совпадение найдено, то метод вернет match-объект, в противном случае - None. Синтаксис метод fullmatch выглядит так:

# re.fullmatch(что искать, где искать)

        # Пример 1

    # Давайте применим метод fullmatch к нашей строке:

'''
txt = '123 456 789'
res = re.fullmatch('\\d+', txt)
print(res)
'''

    # После выполнения кода выведется None, потому что помимо цифр, в строке есть и пробельные символы:

        # Пример 2

    # А теперь пусть наша строка состоит только из цифр:

'''
txt = '123456'
res = re.fullmatch('\\d+', txt)
print(res)
'''

    # Результат выполнения кода:

# <re.Match object; span=(0, 6), match='123456'>

        # Пример 3

    # Из match-объекта можно получить найденную подстроку. Для этого нужно обратиться к его первому элементу:

'''
txt = 'abcde'
res = re.fullmatch('\\w+', txt)
print(res[0])
'''

    # Результат выполнения кода:

# 'abcde'

    # 1

# Проверьте, что следующая строка состоит только из букв: txt = 'abcde'

'''
txt = 'abcde'
res = re.fullmatch('\\w+', txt)
if res[0]:
    print(res[0])
else:
    print('Error')
'''

    # 2

# Проверьте, что следующая строка состоит только из цифр: txt = '12345'

'''
txt = '12345'
res = re.fullmatch('\\d+', txt)
if res[0]:
    print(res[0])
else:
    print('error')
'''

            # 66

            # Карманы в методе fullmatch Python

        # С помощью метода fullmatch также можно разбивать найденное на карманы.

        # Давайте посмотрим на примере. Пусть у нас есть строка:

'''
txt = '123 456 789'

        # Давайте распределим все ее числа по карманам:

res = re.fullmatch('(\\d+)\\s(\\d+)\\s(\\d+)', txt)
print(res[0])
print(res[1])
print(res[2])
print(res[3])
'''

    # 1

# Дана строка: txt = '2025-12-31' Разбейте ее на три кармана.

'''
txt = '2025-12-31'
res = re.fullmatch('(\\d+)-(\\d+)-(\\d+)', txt)
print(res[0])
print(res[1])
print(res[2])
print(res[3])
'''

            # 67

            # Метод match в регулярных выражениях Python

        # Метод match ищет совпадение с регуляркой в начале строки. В первом параметре метода указываем регулярку, которую будем искать, во втором параметре - строку, в которой ее ищем. Если совпадение найдено, то метод вернет match-объект, противном случае - None. 

        # Синтаксис метода выглядит так:

# re.match(что искать, где искать)

        # Давайте для примера проверим, что строка начинается на цифры:

'''
txt = '123abc'
res = re.match('\\d+', txt)
print(res)
'''

    # 1

# Проверьте, что строка начинается на буквы: txt = 'abc 123 bbb 456 987' Выведите совпадение буквенных символов в начале строки.

'''
txt = 'abc 123 bbb 456 987'
res = re.match('(\\w+)', txt)
print(res)
'''

    # 2

# Дана строка: txt = 'aaa bbb 123' Найдите подстроку, содержащую цифры.

'''
txt = 'aaa bbb 123'
res = re.match('(\\w+)\\s(\\w+)\\s(\\d+)', txt)
print(res)
'''

            # 68

            # Карманы в методе match Python

        # При работе с методом match можно разбить найденную подстроку по карманам.

        # Пусть у нас есть строка:

'''
txt = '12 34 56'
res = re.match('(\\d+)(\\d+)', txt)
print(res[0])
print(res[1])
print(res[2])
'''

    # 1

# Дана строка: txt = 'code.mu 1234' Найдите домен, расположенный в начале строки, и положите его имя в первый карман, а зону - во второй.

'''
txt = 'code.mu 1234'
res = re.match('(\\w+).(\\w+)', txt)
print(res[0])
print(res[1])
print(res[2])
'''

    # 2

# Дана строка, содержащая домен: txt = 'sss domain.ru zzz' Найдите этот домен и положите его имя в первый карман, а зону - во второй.

'''
txt = 'sss domain.ru zzz'
res = re.match('\\w+\\s(\\w+)\\.(\\w+)\\s\\w+', txt)
# print(res)
print(res[0])
print(res[1])
print(res[2])
'''

    # 3

# Дана строка, содержащая дату: txt = '31.12.2025' Положите день в первый карман, месяц - во второй, а год - в третий.

'''
txt = '31.12.2025'
res = re.sub('(\\d+).(\\d+).(\\d+)', '\\3.\\2.\\1', txt)
print(res)
'''

            # 69

            # Метод subn в регулярных выражениях Python

        # Метод subn проводит замену символов, заданных в регулярке и возвращает кортеж, состоящий из результата и количества сделанных замен. В первом параметре метода указываем регулярку, которую будем искать, во втором параметре - на что ее меняем. В третьем параметре задаем строку. В четвертом необязательном параметре задаем количество замен:

# re.subn(что меняем, на что меняем, где меняем, [кол-во замен])

        # Пусть у нас есть строка:

'''
txt = '123 456 789'

        # Давайте применим метод subn к нашей строке:

res = re.subn('\\d', '!', txt)
print(res)

        # После выполнения кода выведется измененная строка и количества сделанных в ней замен:

# ('!!! !!! !!!', 9)
'''

    # 1

# Дана строка: txt = 'aaa bbb 123 www' Замените в ней все буквы, повторяющиеся несколько раз подряд и узнайте сколько замен было сделано.

'''
txt = 'aaa bbb 123 www'
res = re.subn('\\w+', '?', txt)
print(res)
'''

    # 2

# Дана строка: txt = 'aaa @@@ 123w' Замените в ней все НЕ буквы и цифры, повторяющиеся несколько раз подряд и узнайте сколько замен было сделано.

'''
txt = 'aaa @@@ 123w'
res = re.subn('[^\\w\\d]', '!', txt)
print(res)
'''

            # 70 

            # Метод split в регулярных выражениях Python

        # Чтобы разбить строку в соответствии с указанной регуляркой, используется метод split. В первом параметре метода указываем регулярку, по которой будем разбивать строку. Во втором параметре задаем строку, которую нам нужно разбить. В третьем необязательном параметре можно указать максимальное количество частей для разбивки. Метод возвращает список частей разбитой строки:

        # Пример 1

'''
txt = 'aaa-bbb-123 456'
res = re.split('-', txt)
print(res)
'''

        # Пример 2

        # А теперь давайте разобьем строку по дефису два раза:

'''
txt = 'aaa-bbb-123-456'
res = re.split('-', txt, 2)
print(res)
'''

    # 1

# Дана строка с датой и временем: txt = '2025-12-31 12:59:59' Разбейте эту строку так, чтобы все год, месяц, день, часы, минуты и секунды находились в одном массиве.

'''
txt = '2025-12-31 12:59:59'
res = re.split('[- :]', txt)
print(res)
'''

            # 71 

            # Несохраняющие скобки в регулярках Python

        # Скобки ( ) выполняют две функции - группировка символов и функцию кармана. А что делать, если нужно сгруппировать, но в карман не класть? Для решения такой проблемы придуманы специальные несохраняющие скобки (?: ) - они группируют, но не кладут в карман.

        # Пример 1

        # В следующем примере первые скобки нам нужны для группировки, а вторые - для кармана. Однако, и те, и другие скобки сохраняют данные в карман:

'''
txt = 'abab123'
res = re.search('(ab)+([1-9]+)', txt)
print(res[0])
print(res[1])
print(res[2])
'''

        # Пример 2

        # Сделаем так, чтобы первая пара скобок только группировала, но не клала в карман:

'''
txt = 'abab123'
res = re.search('(?:ab)+([1-9]+)', txt)
print(res)
print(res[0])
print(res[1])
'''

            # 72

            # Позитивный и негативный просмотр в регулярках Python

        # Иногда нужно решить задачу такого типа: найти строку 'aaa' и заменить ее на '!', но только если после 'aaa' стоит 'x', а сам 'x' при этом не заменять. Если мы попытаемся решить задачу 'в лоб', то у нас ничего не выйдет:

'''
txt = 'aaax aaab'
res = re.sub('aaax', '!', txt)
print(res)
'''
# выведет '! baaa', а хотели '!x baaa' 

            # Просмотр вперед

        # Для решения задачи нужен способ сказать, что 'x' не следует заменять. Делается это с помощью специальных скобок (?= ), которые просто смотрят, но не забирают с собой.

        # Эти скобки называются позитивный просмотр вперед. Позитивный - так как 'x' (в нашем случае) должен быть - только тогда произойдет замена.

        # Давайте применим эти скобки для решения нашей задачи:

'''
txt = 'aaax aaab'
res = re.sub('aaa(?=x)', '!', txt)
print(res)
'''
# выведет '!x aaab

        # Есть и негативный просмотр вперед - (?! ) - он, наоборот, говорит, что чего-то должно не быть. В следующем примере, замена произойдет, только если после 'aaa' стоит НЕ 'x':

'''
txt = 'aaax aaab'
res = re.sub('aaa(?!x)', '!', txt)
print(res)
'''
# выведет 'aaax !b'

            # Просмотр назад

        # Аналогичным образом есть позитивный просмотр назад - (?<= ). В следующем примере замена произойдет, только если перед 'aaa' стоит 'x':

'''
txt = 'xaaa@ axaaa'
res = re.sub('(?<=x)aaa', '!', txt)
print(res)
'''

        # И есть также негативный просмотр назад - (?<! ). В следующем примере замена произойдет, только если перед 'aaa' не стоит 'x':

'''
txt = 'baaa abaaa aabaa'
res = re.sub('(?<!x)aaa', '!', txt)
print(res)
'''

    # 1

# Дана строка, содержащая имена функций: txt = 'func1() func2() func3()' Получите массив имен функций из строки.

'''
txt = 'func1() func2() func3()'
res = re.split('\\(\\)\\s', txt)
print(res)
res2 = re.findall('\\w+\\d', txt)
print(res2)
'''


    # 2

# Дана строка с тегом: txt = '<a href="" class="eee" id="zzz">' Получите массив имен атрибутов этого тега.

'''
txt = '<a href="" class="eee" id="zzz">'
res = re.findall('[a-zA-Zа-яА-ЯёЁ]+="\\w*"', txt)
print(res)
'''

    # 3

# Дана строка с переменными: txt = '$aaa $bbb $ccc xxxx' Получите подстроки, перед которыми стоит символ доллара.

'''
txt = '$aaa $bbb $ccc xxxx'
res = re.findall('\\$\\w+', txt)
print(res)
'''

            # 73

            # Флаги для строк регулярок в Python

        # Чтобы задать флаги как один из необязательных параметров для методов, работающих с регулярками, используют следующий синтаксис:

# flags=re.имя флага

        # re.IGNORECASE	Игнорирование регистра написания символов.

        # re.DOTALL	Точка обозначает любой символ, включая и перенос строки.

        # re.I	Делает поиск нечувствительным к регистру.

        # re.L	Ищет слова в соответствии с текущим языком. Эта интерпретация затрагивает алфавитную группу (\w и \W), а также поведение границы слова (\b и \B).

        # re.M	Символ $ выполняет поиск в конце любой строки текста (не только конце текста) и символ ^ выполняет поиск в начале любой строки текста (не только в начале текста).

        # re.S	Изменяет значение точки (.) на совпадение с любым символом, включая новую строку.

        # re.U	Интерпретирует буквы в соответствии с набором символов Unicode. Этот флаг влияет на поведение \w, \W, \b, \B. В Python 3+ этот флаг установлен по умолчанию.

        # re.X	Позволяет многострочный синтаксис регулярного выражения. Он игнорирует пробелы внутри паттерна (за исключением пробелов внутри набора [] или при экранировании обратным слешем) и обрабатывает не экранированный '#' как комментарий.

        # Пример 1

    # С помощью флага re.IGNORECASE можно игнорировать регистр символов. Давайте посмотрим, как это делается. В этом примере регулярка найдет только маленькие буквы:

'''
txt = 'aaa bbb CCC DDD'
res = re.sub('[a-z]+', '!', txt)
print(res)
# ! ! CCC DDD
res_2 = re.sub('[a-z]+', '!', txt, flags=re.IGNORECASE)
print(res_2)
# ! ! ! !
'''

        # Пример 3

    # Давайте найдем регуляркой все переносы строки:

"""
txt = '''aaa
bbb'''
res = re.sub('\n', '!', txt)
print(res)
"""

        # Пример 4

    # Но, если нужно заменить вообще все символы, то поставив в регулярке точку, не захватятся переносы строки:

"""
txt = '''aaa
bbb'''
res = re.sub('.', '!', txt)
print(res)
#'!!!
#!!!'
"""

        # Пример 5

    # Чтобы исправить данную ошибку, следует применить флаг re.DOTALL:

"""
txt = '''aaa
bbb'''
res = re.sub('.', '!', txt, flags=re.DOTALL)
print(res)
#!!!!!!!
"""

        # Пример 6

    # В параметре можно передать и несколько флагов, поставив между ними оператор +. Давайте сначала заменим букву 'a' в конце строки:

"""
txt = '''
aaa
AAA
aaa'''
res = re.sub('aaa$', '!', txt)
print(res)
'''
aaa
AAA
!
'''

    # Теперь поставим флаг re.M:

res_2 = re.sub('aaa$', '!', txt, flags=re.M)
print(res_2)
'''
!
AAA
!
'''

    # Давайте теперь применим еще и флаг для игнорирования регистра:

res_3 = re.sub('aaa$', '!', txt, flags=re.M+re.IGNORECASE)
print(res_3)
"""