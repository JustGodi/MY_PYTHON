            # Введение в регулярные выражения в Python

        # 33
        
        # Регулярные выражения - это команды для сложного поиска и замены (или просто поиска). Они позволяют делать очень интересные вещи, но, к сожалению, довольно тяжелы в освоении.

        # Чтобы начать работу с регулярными выражениями в Python, нам нужно импортировать специальный модуль re:

import re
        # Модуль re включает в себя методы, предназначенных для работы с регулярными выражениями. Регулярное выражение представляет собой набор команд и состоит из двух типов символов: из тех, которые обозначают сами себя и из символов-команд, которые называются специальные символы.

        # Знакомство с регулярными выражениями лучше начать на примере метода sub, который используется для замен в строке. Первым параметром метод принимает что менять, вторым - на что менять. В третьем параметре указываем строку, в которой нужно сделать замену. В четвертом необязательном параметре задаем количество замен. Самая простая замена с помощью данного метода будет выглядеть вот так:

'''
res = re.sub('a', '!', 'bab')
print(res)
'''

        # Как вы заметили, в регулярном выражении буквы обозначают сами себя. Тоже самое относится и к цифрам. Давайте заменим цифру 2 на !:

'''
res = re.sub('2', '!', '12abc3')
print(res)
'''

        # А вот точка является специальным символом и обозначает любой символ. В следующем примере давайте найдем подстроку по такому шаблону: буква 'x', затем любой символ, затем опять буква 'x':

'''
res = re.sub('x.x', '!', 'xax eee')
print(res)
'''

# 1

# Дана строка: txt = 'ahb acb aeb aeeb adcb axeb' Напишите регулярку, которая найдет строки 'ahb', 'acb', 'aeb' по шаблону: буква 'a', любой символ, буква 'b'.

'''
txt = 'ahb acb aeb aeeb adcb axeb'
print(txt)

txt = re.sub('a.b', '!', txt)
print(txt)
'''

# 2

# Дана строка: txt = 'aba aca aea abba adca abea' Напишите регулярку, которая найдет строки 'abba', 'adca', 'abea' по шаблону: буква 'a', 2 любых символа, буква 'a'.

'''
txt = 'aba aca aea abba adca abea'
print(txt)

txt = re.sub('a..a', '!', txt)
print(txt)
'''

# 3

# Дана строка: txt = 'aba aca aea abba adca abea' Напишите регулярку, которая найдет строки 'abba' и 'abea', не захватив 'adca'.

'''
txt = 'aba aca aea abba adca abea'
print(txt)

txt = re.sub('ab.a', '!', txt)
print(txt)
'''

        # 34

        # Операторы повторения символов в регулярках

        # Бывают ситуации, когда нужно указать, что символ повторяется заданное количество раз. Если точное число повторений неизвестно, то можно просто написать его несколько раз - 'aaaa'. Но что делать, если нужно сказать такое: повторить один или более раз?

        # Для этого существуют операторы (квантификаторы) повторения: плюс + (один и более раз), звездочка * (ноль или более раз) и вопрос ? (ноль или один раз). Эти операторы действуют на тот символ, который стоит перед ними.

'''

# Найдем все подстроки по шаблону буква 'x', буква 'a' один или более раз, буква 'x':

txt = 'xx xax xaax xaaax xbx'
print(txt)
res = re.sub('xa+x', '!', txt)
print(res)
'''

'''
# Найдем все подстроки по шаблону буква 'x', буква 'a' ноль или более раз, буква 'x':

txt = 'xx xax xaax xaaax xbx'
print(txt)
res = re.sub('xa*x', '!', txt)
print(res)
'''

'''
# Найдем все подстроки по шаблону буква 'x', буква 'a' ноль или один раз, буква 'x':

txt = 'xx xax xaax xbx'
print(txt)
res = re.sub('xa?x', '!', txt)
print(res)
'''

# 1

# Дана строка: txt = 'aa aba abba abbba abca abea' Напишите регулярку, которая найдет строки 'aba', 'abba', 'abbba' по шаблону: буква 'a', буква 'b' любое количество раз, буква 'a'.
 
'''
txt = 'aa aba abba abbba abca abea'
print(txt)
txt = re.sub('ab+a', '!', txt)
print(txt)
'''

# 2

# Дана строка: txt = 'aa aba abba abbba abca abea' Напишите регулярку, которая найдет строки 'aa', 'aba', 'abba', 'abbba' по шаблону: буква 'a', буква 'b' любое количество раз (в том числе ни одного раза), буква 'a'.

'''
txt = 'aa aba abba abbba abca abea'
print(txt)
txt = re.sub('ab*a', '!', txt)
print(txt)
'''

# 3

# Дана строка: txt = 'aa aba abba abbba abca abea' Напишите регулярку, которая найдет строки 'aa', 'aba' по шаблону: буква 'a', буква 'b' один раз или ни одного, буква 'a'.

'''
txt = 'aa aba abba abbba abca abea'
print(txt)
txt = re.sub('ab?a', '!', txt)
print(txt)
'''

        # 35

        # Группирующие скобки в регулярках Python

        # В предыдущих примерах операторы повторения действовали только на один символ, который стоял перед ними. Что делать, если нужно подействовать им на несколько символов?

        # Для этого существуют группирующие скобки '(' и ')'. Они работают так: если что-то стоит в группирующих скобках и сразу после ')' стоит оператор повторения - он подействует на все, что стоит внутри скобок.

        # В следующем примере шаблон поиска выглядит так: буква 'x', далее строка 'ab' один или более раз, потом буква 'x':

'''
txt = 'xabx xababx xaabbx'
print(txt)
txt = re.sub('x(ab)+x', '!', txt)
print(txt)
'''

# 1

# Дана строка: txt = 'ab abab abab abababab abea' Напишите регулярку, которая найдет строки по шаблону: строка 'ab' повторяется 1 или более раз.

'''
txt = 'ab abab abab abababab abea'
print(txt)
txt = re.sub('(ab)+', '!', txt)
print(txt)
'''

        # 36

        # Экранировка спецсимволов в регулярках Python

        # Предположим, что нужно сделать так, чтобы спецсимвол обозначал сам себя. Для этого его следует экранировать с помощью обратного слеша. Давайте посмотрим на примерах.

        # В следующем примере автор регулярки хотел, чтобы шаблон поиска выглядел так: буква 'a', затем плюс '+', затем буква 'x'. Однако, автор кода не заэкранировал символ '+' и поэтому шаблон поиска самом деле он выглядит так: буква 'a' один или более раз, потом буква 'x':

'''
txt = 'a+x ax aax aaax'
print(txt)
txt = re.sub('a+x', '!', txt)
print(txt)
'''

        # А сейчас автор заэкранировал плюс обратным слешем. Теперь шаблон поиска выглядит так, как надо: буква 'a', затем плюс '+', затем буква 'x':

'''
txt = 'a+x ax aax aaax'
print(txt)
txt = re.sub('a\\+x', '!', txt)
print(txt)
'''

        # В данном примере шаблон выглядит так: буква 'a', затем точка '.', затем буква 'x':

'''
txt = 'a.x abx azx'
print(txt)
txt = re.sub('a\\.x', '!', txt)
print(txt)
'''


        # А следующем примере автор забыл заэкранировать слеш и под регулярку попали все подстроки, так как незаэкранированная точка обозначает любой символ:

'''
txt = 'a.x abx azx'
print(txt)
txt = re.sub('a.x', '!', txt)
print(txt)
'''

        # Список специальных символов и обычных

        # Если экранировать обычный символ - ничего страшного не случится - он все равно будет обозначать сам себя. Исключение - цифры, их нельзя экранировать.

        # Часто возникает сомнение, является ли данный символ специальным. Некоторые доходят до того, что экранируют все подозрительные символы подряд. Однако, это плохая практика (захламляет регулярку обратными слешами).

        # Являются спецсимволами: $ ^ . * + ? \ / {} [] () |

        # Не являются спецсимволами: @ : , ' " - _ = < > % # ~ `& !

# 1

# ВСЕ ДВОЙНЫЕ СЛЕШИ ЗАМЕНИТЬ НА ОРДИНАРНЫЕ МЕНЯ ЗАЕБАЛА ОШИБКА
# Неподдерживаемая escape-последовательность в строковом литерале

# Дана строка: txt = 'a.a aba aea' Напишите регулярку, которая найдет строку 'a.a', не захватив остальные.

'''
txt = 'a.a aba aea'
print(txt)
txt = re.sub('a\\.a', '!', txt)
print(txt)
'''

# 2 

# Дана строка: txt = '2+3 223 2223' Напишите регулярку, которая найдет строку '2+3', не захватив остальные.

'''
txt = '2+3 223 2223'
print(txt)
txt = re.sub('2\\+3', '!', txt)
print(txt)
'''

# 3

# Дана строка: txt = '23 2+3 2++3 2+++3 345 567' Напишите регулярку, которая найдет строки '2+3', '2++3', '2+++3', не захватив остальные (+ может быть любое количество).

'''
txt = '23 2+3 2++3 2+++3 345 567'
print(txt)
txt = re.sub('2\\++3', '!', txt)
print(txt)
'''

# 4

# Дана строка:txt = '23 2+3 2++3 2+++3 445 677' Напишите регулярку, которая найдет строки '23', '2+3', '2++3', '2+++3', не захватив остальные.

'''
txt = '23 2+3 2++3 2+++3 445 677'
print(txt)
#txt = re.sub('2\\+*3', '!', txt)
print(txt)
'''

# 5 Дана строка:txt = '*+ *q+ *qq+ *qqq+ *qqq qqq+' Напишите регулярку, которая найдет строки '*q+', '*qq+', '*qqq+', не захватив остальные.

'''
txt = '*+ *q+ *qq+ *qqq+ *qqq qqq+'
print(txt)
txt = re.sub('\\*q+\\+', '!', txt)
print(txt)
'''

# 6

# Дана строка: txt = '[abc] {abc} abc (abc) [abc]' Напишите регулярку, которая найдет строки в квадратных скобках и заменит их на '!'.

'''
txt = '[abc] {abc} abc (abc) [abc]'
print(txt)
txt = re.sub('\\[...\\]', '!', txt)
print(txt)
'''

        # 37

        # Фигурные скобки в регулярных выражениях

        # Операторы '+', '*', '?' хороши, однако, с их помощью нельзя указать конкретное число повторений. В этом случае вам на помощь придет оператор {}.

        # Работает он следующим образом: {5} - пять повторений, {2,5} – повторяется от двух до пяти (оба включительно), {2,} - повторяется два и более раз. Посмотрите примеры:


# В данном примере шаблон поиска выглядит так: буква 'x', буква 'a' один или два раза, буква 'x':
'''
txt = 'xx xax xaax xaaax'
res = re.sub('xa{1,2}x', '!', txt)

print(res)
'''


# В данном примере шаблон поиска выглядит так: буква 'x', буква 'a' два раза и более, буква 'x':

'''
txt = 'xx xax xaax xaaax'
res = re.sub('xa{2,}x', '!', txt)

print(res)
'''

# В данном примере шаблон поиска выглядит так: буква 'x', буква 'a' три раза, буква 'x':

'''
txt = 'xx xax xaax xaaax'
res = re.sub('xa{3}x', '!', txt)

print(res)
'''


# В данном примере шаблон поиска выглядит так: буква 'a' десять раз:

'''
txt = 'aaa aaaaaaaaaa aaa'
res = re.sub('a{10}', '!', txt)

print(txt)
print(res)
'''

# В данном примере есть такой шаблон: буква 'x', буква 'a' три раза раза и меньше, буква 'x'. Для того, чтобы его реализовать, перед цифрой 3 можно не указывать число, а поставить просто запятую:

'''
txt = 'xx xax xaax xaaax'
res = re.sub('xa{,3}x', '!', txt)

print(txt)
print(res)
'''

# Ноль перед 3 тоже допустим:

'''
txt = 'xx xax xaax xaaax'
res = re.sub('xa{0,3}x', '!', txt)

print(txt)
print(res)
'''


# 1

# Дана строка: txt = 'aa aba abba abbba abbbba abbbbba' Напишите регулярку, которая найдет строки 'abba', 'abbba', 'abbbba' и только их.

'''
txt = 'aa aba abba abbba abbbba abbbbba'
res = re.sub('ab{2,4}a', '!', txt)

print(txt)
print(res)
'''


# 2

# Дана строка: txt = 'aa aba abba abbba abbbba abbbbba' Напишите регулярку, которая найдет строки вида 'aba', в которых 'b' встречается менее 3-х раз (включительно).

'''
txt = 'aa aba abba abbba abbbba abbbbba'
res = re.sub('ab{,3}a', '!', txt)

print(txt)
print(res)
'''

# 3 

# Дана строка: txt = 'aa aba abba abbba abbbba abbbbba' Напишите регулярку, которая найдет строки вида 'aba', в которых 'b' встречается более 4-х раз (включительно).

'''
txt = 'aa aba abba abbba abbbba abbbbba'
res = re.sub('ab{4,}a', '!', txt)

print(txt)
print(res)
'''


            # 38

            # Ограничение жадности в регулярках в Python

        # Регулярные выражения по умолчанию жадные. Это значит, что они захватывают максимальное возможное количество символов. Давайте разберем на примере. Пусть у нас есть вот такая строка:


#txt = 'aeeex zzz x kkk'

        # В этой строке хотим найти подстроку 'aeeex' по следующему шаблону: буква 'a', затем любой символ один или более раз, затем буква 'x':

#res = re.sub('a.+x', '!', txt)
#print(res)

        # Хотя нам нужно получить строку '! zzz x kkk', выведется строка '! kkk'. Все дело в том, что наша регулярка ищет все символы от буквы 'a' до буквы 'x'. Но в нашей строке две буквы 'x'! Из-за жадности получается, что регулярка ищет до самого последнего икса, тем самым захватывая не то, что нам было нужно.

        # Конечно, зачастую такое поведение нам и требуется. Но конкретно в этом случае нужно отменить жадность и сказать регулярке, чтобы она искала до первого икса. В этом случае следует после оператора повторения поставить знак вопроса:

#txt = 'aeeex zzz x kkk'

#res = re.sub('a.+?x', '!', txt)
#print(res)

        # Жадность можно ограничивать всем операторам повторения: и *, и ?, и {} - вот так: *?, ?? и {}?.

    # 1

# Дана строка: txt = 'aba accca azzza wwwwa' Напишите регулярку, которая найдет все строки по краям которых стоят буквы 'a', и заменит каждую из них на '!'. Между буквами 'a' может быть любой символ (кроме 'a').

'''
txt = 'aba accca azzza wwwwa'
res = re.sub('a.+?a', '!', txt)
print(res)
'''

            # 39

            # Группы символов в регулярных выражениях Python

        # Существуют специальные команды, которые позволяют выбрать сразу целые группы символов. Команда \d означает цифру от 0 до 9. Команда \w обозначает цифру, латинскую букву или знак подчеркивания. Команда \s обозначает пробел или пробельный символ: пробел, перевод строки, табуляцию. Можно инвертировать значение команды, написав большую букву: например, если \d - цифра, то \D - не цифра.

        # Пример 1

'''
txt = '1 12 123'
res = re.sub('\\d', '!', txt)
print(res)
'''

        # Пример 2

    # Операторы повторения считают команды-группы одним целым, то есть группирующие скобки не нужны. В следующем примере шаблон поиска выглядит так: цифра от 0 до 9 один или более раз:

'''
txt = '1 12 123 abc @@@'
res = re.sub('\\d+', '!', txt)
print(res)
'''

        # Пример 3

    # В следующем примере шаблон поиска выглядит так: все что угодно один или более раз, но не цифра от 0 до 9:

'''
txt = '123abc3@@'
res = re.sub('\\D+', '!', txt)
print(res)
'''

        # Пример 4

    # В данном примере шаблон поиска выглядит так: пробельный символ один раз:

'''
txt = '1 12 123 abc    @@'
res = re.sub('\\s', '!', txt)
print(res)
'''

        # Пример 5

    # В данном примере шаблон поиска выглядит так: НЕ пробельный символ один или более раз. Все подстроки, разделенные пробелами, заменятся на '!':

'''
txt = '1 12 123 abc    @@@'
res = re.sub('\\S+', '!', txt)
print(res)
'''

        # Пример 6

    # В данном примере шаблон поиска выглядит так: цифра или буква один или более раз. Все подстроки, состоящие из цифр и букв, заменятся на '!':

'''
txt = '1 12 123a Abc @@@'
res = re.sub('\\w+', '!', txt)
print(res)
'''

        # Пример 7

    # В данном примере шаблон поиска выглядит так: НЕ цифра и НЕ буква один или более раз. Под данное определение в нашем случае попадает '@@@' и все пробелы (они ведь тоже не цифры и не буквы). Обратите внимание на то, что в конце один '!' - в него преобразовалась строка ' @@@' - с пробелом впереди:

'''
txt = '1 12 123 Abc @@@'
res = re.sub('\\W+', '!', txt)
print(res)
'''

    # 1

# Дана строка: txt = 'a1a a2a a3a a4a a5a aba aca' Напишите регулярку, которая найдет строки, в которых по краям стоят буквы 'a', а между ними одна цифра.

'''
txt = 'a1a a2a a3a a4a a5a aba aca'
res = re.sub('a\\da', '!', txt)
print(res)
'''

    # 2

# Дана строка: txt = 'a1a a22a a333a a4444a a55555a aba aca' Напишите регулярку, которая найдет строки, в которых по краям стоят буквы 'a', а между ними любое количество цифр.

'''
txt = 'a1a a22a a333a a4444a a55555a aba aca'
res = re.sub('a\\d*a', '!', txt)
print(res)
'''

    # 3

# Дана строка: txt = 'aa a1a a22a a333a a4444a a55555a aba aca' Напишите регулярку, которая найдет строки, в которых по краям стоят буквы 'a', а между ними любое количество цифр (в том числе и ноль цифр, то есть строка 'aa').

'''
txt = 'aa a1a a22a a333a a4444a a55555a aba aca'
res = re.sub('a\\d*a', '!', txt)
print(res)
'''

    # 4

# Дана строка: txt = 'avb a1b a2b a3b a4b a5b abb acb' Напишите регулярку, которая найдет строки следующего вида: по краям стоят буквы 'a' и 'b', а между ними - не число и не пробел.

'''
txt = 'avb a1b a2b a3b a4b a5b abb acb'
res = re.sub('a[^0-9 ]b', '!', txt)
print(res)
'''

    # 5

# Дана строка: txt = 'ave a#b a2b a$b a4b a5b a-b acb' Напишите регулярку, которая найдет строки следующего вида: по краям стоят буквы 'a' и 'b', а между ними - не буква, не цифра и не пробел.

'''
txt = 'ave a#b a2b a$b a4b a5b a-b acb'
res = re.sub('a[^a-zA-Z0-9 ]b', '!', txt)
print(res)
'''

    # 6

# Дана строка: txt = 'ave a#a a2a a$a a4a a5a a-a aca' Напишите регулярку, которая заменит все пробелы на '!'.

'''
txt = 'ave a#a a2a a$a a4a a5a a-a aca'
#res = re.sub(' ', '!', txt)
res = re.sub('\\s', '!', txt)
print(res)
'''

            # 40

            # Наборы символов в регулярных выражениях Python

        # Группы символов \d и \w не очень гибкие. Даже такая простая задача, как найти все буквы, но не цифры - не может быть решена ими. Для таких задач следует использовать квадратные скобки, представляющие собой операцию 'или'.

        # Квадратные скобки заменяют собой один символ, любой из перечисленных внутри. К примеру, вот так: x[abc]x - мы говорим, что по краям должны стоять буквы икс, а внутри - один символ: или 'a', или 'b', или 'c'.

        # После квадратных скобок можно писать операторы повторения. К примеру, вот так: x[abc]+x - мы говорим, что внутри иксов может быть любое количество символов 'a', 'b' и 'c' - в любых комбинациях.

        # Можно не только перечислять символы, но создавать группы символов, записывая между двумя символами дефис. К примеру, вот так: [a-d] - мы получаем все символы от 'a' до 'd'.

        # Пример 1

    # В данном примере шаблон поиска выглядит так: между иксами любая буква от 'a' до 'z':

'''
txt = 'xax xbx xzx x@x'
res = re.sub('x[a-z]x', '!', txt)
print(res)
'''

        # Пример 2
    
    # В данном примере шаблон поиска выглядит так: между иксами любая буква от 'a' до 'k':

'''
txt = 'xax xbx xlx x@x'
res = re.sub('x[a-k]x', '!', txt)
print(res)
'''

        # Пример 3

    # В данном примере шаблон поиска выглядит так: между иксами любая буква от 'A' до 'Z':

'''
txt = 'xax xBx xcx xCx xXx xzx xZx xAx x@x'
res = re.sub('x[A-Z]x', '!', txt)
print(txt)
print(res)
'''

        # Пример 4

    # В данном примере шаблон поиска выглядит так: между иксами любая цифра от 0 до 9:

'''
txt = 'xax x0x x5x x9x x@x'
res = re.sub('x[0-9]x', '!', txt)
print(txt)
print(res)
'''

        # Пример 5

    # В данном примере шаблон поиска выглядит так: между иксами любая цифра от 3 до 7:

'''
txt = 'xax x1x x3x x5x x@x'
res = re.sub('x[3-7]x', '!', txt)
print(txt)
print(res)
'''

        # Пример 6

    # В данном примере шаблон поиска выглядит так: между иксами любая буква от 'a' до 'z' или цифра от 1 до 9:

'''
txt = 'xax x1x x3x x5x x@x'
res = re.sub('x[a-z1-9]x', '!', txt)
print(txt)
print(res)
'''

        # Пример 7

    # В данном примере шаблон поиска выглядит так: между иксами любая буква от 'a' до 'z' или буква от 'A' до 'Z':

'''
txt = 'xax xBx xcx x5x x@x'
res = re.sub('x[a-zA-Z]x', '!', txt)
print(txt)
print(res)
'''

        # Пример 8

    # В данном примере шаблон поиска выглядит так: между иксами любая буква от 'a' до 'z' или цифры 1, 2:

'''
txt = 'xax xbx x1x x2x x3x'
res = re.sub('x[a-z12]x', '!', txt)
print(txt)
print(res)
'''

        # Пример 9

    # В данном примере шаблон поиска выглядит так: между иксами буквы от 'a' до 'z' в количестве от 1 и более:

'''
txt = 'xx xabesx xaadx x123x xa3x'
res = re.sub('x[a-z]+x', '!', txt)
print(txt)
print(res)
'''

        # Пример 10

    # Сделаем так, чтобы количество букв могло быть и ноль:

'''
txt = 'xx xabesx xaadx x123x xa3x'
res = re.sub('x[a-z]*x', '!', txt)
print(txt)
print(res)
'''

        # Пример 11

    # Внутри квадратных скобок также можно указывать экранированные символы. Давайте найдем последовательность букв и цифр, повторяющуюся ноль или более раз:

'''
txt = 'xx x@x xadx xas12x xa3x'
res = re.sub('x[a-z\\d]*x', '!', txt)
print(txt)
print(res)
'''

        # Пример 12

    # Если же нам нужно указать еще одни квадратные скобки, то мы их тоже обязательно экранируем:

'''
txt = 'xx x[]x xrx xas[]x x3x'
res = re.sub('x[a-z\\[\\]]*x', '!', txt)
print(txt)
print(res)
'''

        # Практические задачи

    # 1

#Дана строка: txt = 'aba aea aca aza axa' Напишите регулярку, которая найдет по следующему шаблону: по краям стоят буквы 'a', а между ними - буква 'b', 'e' или 'x'.

'''
txt = 'aba aea aca aza axa'
res = re.sub('a[bex]a', '!', txt)
print(txt)
print(res)
'''

    # 2

# Дана строка: txt = 'a1a a3a a7a a9a aba' Напишите регулярку, которая найдет по следующему шаблону: по краям стоят буквы 'a', а между ними - цифра от 3-х до 6-ти.

'''
txt = 'a1a a3a a7a a9a aba'
res = re.sub('a[3-7]a', '!', txt)
print(txt)
print(res)
'''

    # 3

# Дана строка: txt = 'aba aea afa aha aga' Напишите регулярку, которая найдет по следующему шаблону: по краям стоят буквы 'a', а между ними - буква от 'a' до 'g'.

'''
txt = 'aba aea afa aha aga'
res = re.sub('a[a-g]a', '!', txt)
print(txt)
print(res)
'''

    # 4

# Дана строка: txt = 'aba aea afa aha aga' Напишите регулярку, которая найдет по следующему шаблону: по краям стоят буквы 'a', а между ними - буква от 'a' до 'f' и от 'j' до 'z'.

'''
txt = 'aba aea afa aha aga aia aka aqa aza'
res = re.sub('a[a-fj-z]a', '!', txt)
print(txt)
print(res)
'''

    # 5

# Дана строка: txt = 'aAa aea aEa aJa a3a' Напишите регулярку, которая найдет по следующему шаблону: по краям стоят буквы 'a', а между ними - буква от 'a' до 'f' и от 'A' до 'D'.

'''
txt = 'aAa aea aEa aJa a3a'
res = re.sub('a[a-fA-D]a', '!', txt)
print(txt)
print(res)
'''

    # 6 

# Дана строка: txt = 'aAXa aeffa aGha aza ax23a a3sSa' Напишите регулярку, которая найдет по следующему шаблону: по краям стоят буквы 'a', а между ними - маленькие латинские буквы, не затронув остальных.

'''
txt = 'aAXa aeffa aGha aza ax23a a3sSa'
res= re.sub('a[a-z]*a', '!', txt)
print(txt)
print(res)
'''

    # 7

# Дана строка: txt = 'aAXa aeffa aGha aza ax23a a3sSa' Напишите регулярку, которая найдет по следующему шаблону: по краям стоят буквы 'a', а между ними - маленькие и большие латинские буквы, не затронув остальных.

'''
txt = 'aAXa aeffa aGha aza ax23a a3sSa'
res = re.sub('a[a-zA-Z]*a', '!', txt)
print(txt)
print(res)
'''

    # 8

# Дана строка: txt = 'aAXa aeffa aGha aza ax23a a3sSa' Напишите регулярку, которая найдет по следующему шаблону: по краям стоят буквы 'a', а между ними - маленькие латинские буквы и цифры, не затронув остальных.

'''
txt = 'aAXa aeffa aGha aza ax23a a3sSa'
res = re.sub('a[a-z\\d]*a', '!', txt)
print(txt)
print(res)
'''

            # 41

            # Инвертирование наборов символов в регулярках

        # С помощью шляпки '^' в начале квадратных скобок можно инвертировать желаемое. Если, к примеру, команда [ab] ищет букву 'a' или 'b', то команда [^ab] будет искать все символы, кроме 'a' и 'b'.

        # Пример 1

    # В данном примере шаблон поиска выглядит так: буква 'x', затем НЕ буква 'a', не 'b' и не 'c', потом буква 'z':

'''
txt = 'xaz xbz xcz xez'
res = re.sub('x[^abc]z', '!', txt)
print(txt)
print(res)
'''

        # Пример 2

    # В данном примере шаблон поиска выглядит так: буква 'x', затем НЕ маленькая латинская буква, потом буква 'z':

'''
txt = 'xaz xbz x1z xСz'
res = re.sub('x[^a-z]z', '!', txt)
print(txt)
print(res)
'''

        # Практические задачи

    # 1

# Напишите регулярку, которая найдет строки по шаблону: цифра 1, затем символ не 'e' и не 'x', цифра 2.

'''
txt = '1x2 1e2 1E2 1X2 132 1@2 1x2 1e2'
res = re.sub('1[^ex]2', '!', txt)
print(txt)
print(res)
'''

    # 2

# Напишите регулярку, которая найдет строки по шаблону: буква 'x', затем НЕ цифра от 2 до 7, буква 'z'.

'''
txt = 'x2z x7z x1z x8z xsz x@z x7z x2z'
res = re.sub('x[^2-7]z', '!', txt)
print(txt)
print(res)
'''

    # 3

# Напишите регулярку, которая найдет строки по шаблону: буква 'x', затем НЕ большая латинская буква от 1 и более раз, буква 'z'.

'''
txt = 'xAz xaz xAz x2z xAz x@z xAz xqweqrwwqz  xqwezz xB2C3Dz xqw12@!xszz xV@A2A$Fx'
res = re.sub('x[^A-Z]+?z+', '!', txt)
print(txt)
print(res)
'''

    # 4

# Напишите регулярку, которая найдет строки по шаблону: буква 'x', затем НЕ большая или маленькая латинская буква и не цифра от 1 до 5 от 1 и более раз, буква 'z'.

'''
txt = 'xAz xaz x1z x6z xA@AZz x@z x23z x67890z x@Zz'
res = re.sub('x[^A-Z1-5]+?z+', '!', txt)
print(txt)
print(res)
'''

            # 42

            # Oсобенности кириллицы в регулярках Python

        # Большим преимуществом регулярок в Python является то, что кириллические символы входят в группу \w. Давайте заменим все латинские и кириллические буквы в следующей строке:

'''
txt = 'x232x 456 xax xтекстx'
res = re.sub('x[\\w]*x', '!', txt)
print(txt)
print(res)
'''

        # Также кириллические буквы можно искать с помощью группы в квадратных скобках: [а-я]. Но с ней есть проблема - сюда не войдет буква 'ё'. Для ее включения нужно дописать эту букву к группе:

'''
txt = 'x232x 456 хbёх хётекстх'
res = re.sub('х[а-яё]*х', '!', txt)
print(txt)
print(res)
'''


    # 1

# Дана строка: txt = 'wйw wяw wёw wqw' Напишите регулярку, которая найдет строки по шаблону: по краям стоят буквы 'w', а между ними - буква кириллицы.

'''
txt = 'wйw wяw wёw wqw'
res = re.sub('w[а-яё]+w', '!', txt)
print(txt)
print(res)
'''

    # 2

# Дана строка: txt = 'ааа ббб ёёё ззз ййй ААА БББ ЁЁЁ ЗЗЗ ЙЙЙ' Напишите регулярку, которая найдет все слова по шаблону: любая кириллическая буква любое количество раз.

'''
txt = 'ааа ббб ёёё ззз ййй ААА БББ ЁЁЁ ЗЗЗ ЙЙЙ'
res = re.sub('[а-яёА-ЯЁ]+', '!', txt)
print(txt)
print(res)
'''

            # 43

            # Спецсимволы внутри квадратных скобок в Python

        # Спецсимволы внутри [ ] становятся обычными символами. Это значит, что их не надо экранировать обратным слешем.

        # Пример 1

    # В данном примере шаблон поиска выглядит так: между иксами любая буква 'a', 'b', 'c', либо точка:

'''
txt = 'xax xbx xcx xdx x.x x@x'
res = re.sub('x[abc.]x', '!', txt)
print(txt)
print(res)
'''

        # Пример 2

    # В данном примере шаблон поиска выглядит так: между иксами любая маленькая латинская буква или точка:

'''
txt = 'xax xbx xcx x@x'
res = re.sub('x[a-z.]x', '!', txt)
print(txt)
print(res)
'''


    # 1

# Дана строка: txt = 'aba aea aca aza axa a.a a+a a*a' Напишите регулярку, которая найдет строки 'a.a', 'a+a', 'a*a', не затронув остальных.

'''
txt = 'aba aea aca aza axa a.a a+a a*a'
res = re.sub('a[\\.\\+\\*]a', '!', txt)
print(txt)
print(res)
'''

    # 2

# Дана строка: txt = 'xaz x.z x3z x@z x$z xrz Напишите регулярку, которая найдет строки по шаблону: буква 'x', затем НЕ точка, НЕ собака, и НЕ доллар, а потом буква 'z'.

'''
txt = 'xaz x.z x3z x@z x$z xrz x(z'
res = re.sub('x[^\\.\\$\\(]z', '!', txt)
print(txt)
print(res)
'''

            # 44

            # Группы символов внутри наборов в регулярках Python

        # Группы символов \d, \D, \w, \W, \s, \S внутри [] будут обозначать именно группы, то есть по-прежнему будут командами.

        # Пример 1

    # В данном примере шаблон поиска выглядит так: между иксами любая цифра, либо буква от 'a' до 'f':

'''
txt = 'xax xbx x1x x2x xhx x@x'
res = re.sub('x[\\da-f]x', '!', txt)
print(txt)
print(res)
'''

        # Пример 2

    # В данном примере шаблон поиска выглядит так: буква 'x', затем не цифра, не точка, и не маленькая латинская буква, затем буква 'z':

'''
txt = 'xaz x1z xAz x.z x@z'
res = re.sub('x[^\\d.a-z]z', '!', txt)
print(txt)
print(res)
'''

    # 1

# Напишите регулярку, которая найдет строки по шаблону: цифра или точка от 1 и более раз.

'''
txt = 'a x 12 1.1.1 a1sd a.asd ... .1.1. @.@.@'
res = re.sub('[\\d.]+', '!', txt)
print(txt)
print(res)
'''

    # 2

# Напишите регулярку, которая найдет строки по шаблону: не цифра и не буква от 'a' до 'g' от 3 до 7 раз.

'''
txt = 'hh hhh ##@. #@># ##@@$$.. asdsa 43ad31 123.123 abc...abc ff ffff 1111'
res = re.sub('[^\\da-g{3, 7}]', '!', txt)
print(txt)
print(res)
'''

            # 45

            # Исключения внутри наборов в регулярках Python

            # Вы уже знаете, что спецсимволы внутри [] становятся обычными символами. Есть, однако, исключения: если вам нужны квадратные скобки как символы внутри [ ] - то их нужно экранировать обратным слешем. Для примера в следующем коде шаблон поиска выглядит так: между иксами стоит квадратная скобка:

'''
txt = 'x]x xax x[x x1x'
res = re.sub('x[\\[\\]]x', '!', txt)
print(txt)
print(res)
'''

    # 1

# Дана строка: txt = 'x[]z x[[]]z x()z' Напишите регулярку, которая найдет все слова по шаблону: буква 'x', затем квадратные скобки любое количество раз, затем буква 'z'.

'''
txt = 'x[]z x[[]]z x()z'
res = re.sub('x[\\[\\]]*z', '!', txt)
print(txt)
print(res)
'''

    # 2

# Дана строка: txt = 'x[]z x{}z x.z x()z x([])z' Напишите регулярку, которая найдет все слова по шаблону: буква 'x', затем любое количество любых скобок, затем буква 'z'.

'''
txt = 'x[]z x{}z x.z x()z x([])z'
res = re.sub('x[\\[\\]\\(\\)\\{\\}]*z', '!', txt)
print(txt)
print(res)
'''

            # 46

            # Символ шляпки внутри наборов в регулярках Python

        # Как вы знаете, шляпка внутри [ ] делает отрицание, будучи написанной в начале скобок. Значит, она является спецсимволом внутри этих скобок. Чтобы получить шляпку как символ, нужно или заэкранировать ее, или убрать с первого места.

        # Пример 1

'''
txt = 'axx bxx ^xx dxx'
res = re.sub('[^d]xx', '!', txt)
print(txt)
print(res)
'''

        # Пример 2

    # А теперь шаблон поиска такой: первый символ - это 'd' или '^', потом две буквы 'x':

'''
txt = 'axx bxx ^xx dxx'
res = re.sub('[d^]xx', '!', txt)
print(txt)
print(res)
'''

        # Пример 3

    # Можно не убирать шляпку с первого места, а просто заэкранировать ее с помощью обратного слеша, и она станет обозначать саму себя:

'''
txt = 'axx bxx ^xx dxx'
res = re.sub('[\\^d]xx', '!', txt)
print(txt)
print(res)
'''

    # 1

# Дана строка: txt = '^xx axx ^zz bkk @ss' Напишите регулярку, которая найдет строки по шаблону: шляпка или собака, а затем две латинских буквы.

'''
txt = '^xx axx ^zz bkk @ss'
res = re.sub('[@^][a-zA-Z]{2}', '!', txt)
#res = re.sub('[@^][a-zA-Z][a-zA-Z]', '!', txt)
print(txt)
print(res)
'''

    # 2

# Дана строка: txt = '^xx axx ^zz bkk @ss' Напишите регулярку, которая найдет строки по шаблону: НЕ шляпка и не собака, а затем две латинских буквы.

'''
txt = '^xx axx ^zz bkk @ss'
res = re.sub('[^\\s\\^\\@][a-zA-Z]{2}', '!', txt)
print(txt)
print(res)
'''

    # 3

# Дана строка: txt = '^xx axx ^zz bkk' Напишите регулярку, которая найдет строки по шаблону: не шляпка и не пробел, а затем две латинских буквы.

'''
txt = '^xx axx ^zz bkk'
res = re.sub('[^\\^\\s][a-zA-Z]{2}', '!', txt)
print(txt)
print(res)
'''

            # 47

            # Дефис внутри наборов в регулярках Python

        # Дефис - тоже спецсимвол внутри [ ] (а вот снаружи - нет). Если вам нужен сам дефис как символ - то поставьте его там, где он не будет воспринят как разделитель группы.

        # Почему это важно: вы можете сделать группу символов, сами не заметив этого. К примеру, вот так - '[:-@]' - вы думаете, что выбираете двоеточие, дефис и собаку, а на самом деле получается группа символов между : и @. В эту группу входят следующие символы: ? < = > :

        # Откуда они взялись? Из таблицы ASCII - двоеточие имеет номер меньше, чем собака - и получается группа. То есть все группы получаются по таблице ASCII (при желании этим можно пользоваться).

        # Как с этим бороться: поставьте символ дефиса там, где он точно не будет воспринят как символ группы, например, в начале или в конце (то есть после [или перед ]).

        # Можно также заэкранировать дефис - тогда он будет обозначать сам себя независимо от позиции. Например, вместо [:-@] написать [:\-@] - и группы уже не будет, а будут три символа - двоеточие, дефис и собака @.


        # Пример 1

    # В следующем примере шаблон поиска такой: цифра 1, затем буква от 'a' до 'z', затем цифра 2:

'''
txt = '1a2 1-2 1c2 1z2'
res = re.sub('1[a-z]2', '!', txt)
print(txt)
print(res)
'''

        # Пример 2

    # Давайте теперь заэкранируем дефис. В результате шаблон поиска такой: цифра 1, затем буква 'a', или дефис, или буква 'z', затем цифра 2:

'''
txt = '1a2 1-2 1c2 1z2'
res = re.sub('1[a\\-z]2', '!', txt)
print(txt)
print(res)
'''

        # Пример 3

    # Можно просто переставить дефис, не экранируя его:

'''
txt = '1a2 1-2 1c2 1z2'
res = re.sub('1[az-]2', '!', txt)
print(txt)
print(res)
'''

        # Пример 4

    # В следующем примере шаблон поиска такой: первый символ - это маленькие буквы или дефис '-', потом две буквы 'x':

'''
txt = 'axx Axx -xx @xx'
res = re.sub('[a-z-]xx', '!', txt)
print(txt)
print(res)
'''

        # Пример 5

    # В следующем примере шаблон поиска такой: первый символ - это маленькие, большие буквы или дефис '-', потом две буквы 'x':
'''
txt = 'axx Axx -xx @xx'
res = re.sub('[a-zA-Z-]xx', '!', txt)
print(txt)
print(res)
'''

        # Пример 6

    # Можно расположить дефис между двумя группами - там он точно еще не сделает еще одну группу:

'''
txt = 'axx 9xx -xx @xx'
res = re.sub('[a-z-0-9]xx', '!', txt)
print(txt)
print(res)
'''

    # 1

# Дана строка: txt = 'xaz xBz xcz x-z x@z' Найдите все строки по следующему шаблону: буква 'x', большая или маленькая буква или дефис, буква 'z'.

'''
txt = 'xaz xBz xcz x-z x@z'
res = re.sub('x[a-zA-Z-]z', '!', txt)
print(txt)
print(res)
'''

    # 2

# Дана строка: txt = 'xaz x$z x-z xcz x+z x%z x*z' Найдите все строки по следующему шаблону: буква 'x', затем или доллар, или дефис или плюс, потом буква 'z'.

'''
txt = 'xaz x$z x-z xcz x+z x%z x*z'
res = re.sub('x[-$+]z', '!', txt)
print(txt)
print(res)
'''

            # 48

            # Начало и конец строки в регулярках Python

        # Пример 1

    # В данном примере шаблон поиска такой: заменить 'aaa' на '!' только, если оно стоит в начале строки:

'''
txt = 'aaa aaa aaa'
res = re.sub('^aaa', '!', txt)
print(txt)
print(res)
'''

        # Пример 2

    # В данном примере шаблон поиска такой: заменить 'aaa' на '!' только, если оно стоит в конце строки:

'''
txt = 'aaa aaa aaa'
res = re.sub('aaa$', '!', txt)
print(txt)
print(res)
'''

        # Пример 3

    # Когда в начале регулярки стоит '^', а в конце - '$', то таким образом проверяется вся строка целиком на соответствие регулярке.

    # В следующем примере шаблон поиска такой: буква 'a' повторяется один или более раз, заменить всю строку на '!' только она состоит из одних букв 'a':

'''
txt = 'aaa'
res = re.sub('a+$', '!', txt)
print(txt)
print(res)
'''

    # 1

# Дана строка: txt = 'abc def xyz' Напишите регулярку, которая найдет первую подстроку из букв.

'''
txt = 'abc def xyz'
res = re.sub('^...', '!', txt)
print(txt)
print(res)
'''

    # 2

# Дана строка: txt = 'abc def xyz' Напишите регулярку, которая найдет последнюю подстроку из букв.

'''
txt = 'abc def xyz'
res = re.sub('...$', '!', txt)
print(txt)
print(res)
'''

            # 49

            # Границы слов в регулярках Python

        # С помощью команды '\\b' можно обратиться к границе слова, а с помощью команды '\B' или '\\B' - не к границе. Обратите внимание на то, что в случае определения границы слов в Python работает экранирование строго с помощью двух слешей, хотя для других команд допускается один слеш. Давайте посмотрим работу этих команд на примерах.

        # Пример 1

    # Давайте обернем каждое слово в символ '!':

'''
txt = 'aaa aaa aaa'
print(re.sub('\\b', '!', txt))
'''

        # Пример 2

    # Давайте добавим символ '!' в промежутки между буквами:

'''
txt = 'aaa aaa aaa'
print(re.sub('\\B', '!', txt))
'''

    # 1

# Дана строка: txt = 'abc def xyz' Напишите регулярку, которая сделает из этой строки следующую: '#abc# #def# #xyz#'

'''
txt = 'abc def xyz'
print(re.sub('\\b', '#', txt))
'''

    # 2

# Дана строка: txt = 'abc def xyz' Напишите регулярку, которая сделает из этой строки следующую: 'a+b+c d+e+f x+y+z'

'''
txt = 'abc def xyz'
print(re.sub('\\B', '+', txt))
'''

            # 50

            # Многострочность в регулярках Python

        # Регулярки при работе с многострочными строками имеют свои особенности. Давайте с ними разбираться на примере следующей строки, содержащей обычные символы, символы перевода строк и табуляции:
"""
txt = '''
    111
    222
    333
    444
'''
"""
        # Перевод строки

    # Символы перевода строки можно поймать с помощью команды '\n':
'''
res = re.sub('\\n', '!', txt)
print(txt)
print(res)
'''

        # Табуляция

    # Символы табуляции можно поймать с помощью команды '\t':

'''
res = re.sub('\\t', '!', txt)
print(txt)
print(res)
'''

        # Работа точки

    # Команда '.' для многострочной строки не ловит символы перевода строки:

'''
res = re.sub('.', '!', txt)
print(txt)
print(res)
'''

        # Команда '.' для многострочной строки не ловит символы перевода строки:

    # Чтобы поймать все символы в многострочной строке, используется хитрый прием в виде сочетания [\s\S]. Такая конструкция найдет все обычные символы и все переводы строк:

'''
res = re.sub('[\\s\\S]', '!', txt)
print(txt)
print(res)
'''

        # Доллар

    # Команда '$' в многострочном режиме будет ловить конец каждой строки:

'''
res = re.sub('$', '!', txt)
print(txt)
print(res)
'''

    # 1

# Дана строка:

'''
	abc
	def
	ghi
	jkl
'''
# Напишите регулярку, которая сделает из этой строки следующую:

'''
	abc!
	def!
	ghi!
	jkl!
'''

"""
txt = '''    abc
    def
    ghi
    jkl'''
res = re.sub('$', '!', txt, flags=re.MULTILINE)
print(res)
"""

    # 2

# Дана строка:

'''
    abc
    def
    ghi
    jkl
'''
# Напишите регулярку, которая сделает из этой строки следующую:

'''
!	abc
!	def
!	ghi
!	jkl
'''

"""
txt = '''    abc
    def
    ghi
    jkl'''

res = re.sub('^', '!', txt, flags=re.MULTILINE)
print(txt)
print(' ')
print(res)
"""

    # 3 

# Дана строка:

'''
    abc
    def
    ghi
    jkl
'''
# Напишите регулярку, которая сделает из этой строки следующую:

'''!
    abc
    def
    ghi
    jkl
!'''

"""
txt = '''
    abc
    def
    ghi
    jkl
'''
res = re.sub('\\Z', '!', txt, flags=re.DEBUG)
res = re.sub('\\A', '!', res)
print((res))
"""

    # 4

# Дана строка:

'''
	abc
	def
	ghi
	jkl
'''

# Напишите регулярку, которая сделает из этой строки следующую:

'''!
!	abc
!	def
!	ghi
!	jkl
!'''

"""
txt = '''
    abc
    def
    ghi
    jkl
'''
res = re.sub('^', '!', txt, flags=re.MULTILINE)
print(res)
"""

    # 5

# Дана строка:

'''
	abc
	def
	ghi
	jkl
'''

# Напишите регулярку, которая сделает из этой строки следующую:

'''!
	abc!
	def!
	ghi!
	jkl!
!'''

"""
txt = '''
    abc
    def
    ghi
    jkl
'''
res = re.sub('$', '!', txt, flags=re.MULTILINE)
print(res)
"""

    # 6

# Дана строка:

'''
	abc
	def
	ghi
	jkl
'''

# Напишите регулярку, которая сделает из этой строки следующую:

'''
	!abc
	!def
	!ghi
	!jkl
'''

"""
txt = '''
    abc
    def
    ghi
    jkl
'''
res = re.sub(r'^(\\s*)',
    r'\1!',
    txt,
    flags=re.MULTILINE)
print(res)
"""

            # 51

            # Команда 'или' в регулярных выражениях Python

        # Команда '|', которая представляет собой более мощный вариант 'или' по сравнению с командой [ ]. Данная команда позволяет разделить регулярку на несколько частей. При этом искомое может попасть либо под одну часть регулярки, либо под другую. Давайте посмотрим на примерах.

        # Пример 1

    # В данном примере шаблон поиска такой: три буквы 'a' или три буквы 'b':

'''
txt = 'aaa bbb abb'
res = re.sub('a{3}|b{3}', '!', txt)
print(res)
'''

        # Пример 2

    # В данном примере шаблон поиска такой: три буквы 'a' или от 1 и более букв 'b':

'''
txt = 'aaa bbb bbbb bbbbb axx'
res = re.sub('a{3}|b+', '!', txt)
print(res)
'''

        # Пример 3

    # В данном примере шаблон поиска такой: одна или более буквы или три цифры:

'''
txt = 'a ab abc 1 12 123'
res = re.sub('[a-z]+|\\d{3}', '!', txt)
print(res)
'''

        # Пример 4

    # Вертикальная черта может делить регулярку не на две части, а на любое количество частей:

'''
txt = 'aaa bbb ccc ddd'
res = re.sub('a+|b+|c+', '!', txt)
print(res)
'''

        # Пример 5

    # Если вертикальная черта стоит внутри круглых скобок, то 'или' работает только внутри этих скобок.

    # Для примера давайте найдем строки по следующему шаблону: в начале стоит или 'a', или 'b' один или более раз, а потом две буквы 'x':

'''
txt = 'axx bxx bbxx exx'
res = re.sub('(a|b+)xx', '!', txt)
print(res)
'''

    # 1

# Дана строка: txt = 'aeeea aeea aea axa axxa axxxa' Напишите регулярку, которая найдет строки по шаблону: по краям стоят буквы 'a', а между ними - или буква 'e' любое количество раз или буква 'x' любое количество раз.

'''
txt = 'aeeea aeea aea axa axxa axxxa'
res = re.sub('a(e*|x*)a', '!', txt)
print(res)
'''

    # 2

# Дана строка: txt = 'aeeea aeea aea axa axxa axxxa' Напишите регулярку, которая найдет строки по шаблону: по краям стоят буквы 'a', а между ними - или буква 'e' два раза или буква 'x' любое количество раз.

'''
txt = 'aeeea aeea aea axa axxa axxxa'
res = re.sub('a(e{2}|x*)a', '!', txt)
print(res)
'''

            # 52

            # Метод search в регулярных выражениях Python

        # В предыдущих уроках мы изучали регулярки с помощью метода для поиска и замены. Существуют и другие методы. В данном уроке мы начнем их изучать.

        # Новый метод, который мы изучим, называется search. Он ищет первое совпадение с регуляркой в строке. В первом параметре метода нужно указать регулярку, которую будем искать, во втором параметре - строку, в которой ее ищем. Метод проверяет совпадения, проходя по строке слева направо.

        # Своим результатом метод возвращает специальный match-объект, содержащий информацию о найденной подстроке и ее расположении в исходной строке.

        # Давайте попробуем на практике. Найдем первую подстроку с цифрами с помощью метода search:

'''
txt = 'aaa 123 bbb 456'
res = re.search('\\d+', txt)
print(res)
        # А теперь выведем найденный текст. Он попадет попадает в нулевой элемент match-объекта:
print(res[0])
'''

    # 1

# Дана строка: txt = '123 abc 456 cde' Найдите первую подстроку, содержащую только буквенные символы. Выведите ее в консоль.

'''
txt = '123 abc 456 cde'
res = re.search('[a-zA-Zа-яА-ЯёЁ]+', txt)
print(res)
print(res[0])
'''

    # 2

# Дана строка: txt = '1 23 456 789' Найдите позицию первого числа, состоящего из трех цифр.

'''
txt = '1 23 456 789'
res = re.search('[0-9]{3}', txt)
print(res)
print(res[0])
'''

            # 53

            # Позиция найденного в методе search Python

        # С помощью match-объекта можно также определить позицию найденной подстроки. Для этой цели применяются два метода. Метод start возвращает позицию начала, а метод end - позицию конца.

        # Давайте попробуем на практике. Пусть у нас есть строка:

'''
txt = '123 456 789'

        # Давайте найдем в ней первую подстроку с цифрами через метод search, а затем выведем позицию полученной подстроки с помощью методов start и end:

res = re.search('\\d+', txt)
print(res)
print(res[0])
print(res.start())
print(res.end())
'''

    # 1
 
# Дана строка: txt = 'abcde 123456' Найдите в ней подстроку, состоящую только из букв. Выведите позицию начала и конца найденной подстроки.

'''
txt = 'abcde 123456'
res = re.search('\\w+', txt)
print(res)
print(res[0])
print(res.start())
print(res.end())
'''

            # 54

            # Карманы в методе search Python

        # Часто при поиске совпадения удобно разложить подстроку на так называемые карманы. Они представляют собой способ разбить найденное на отдельные части. Для их использования нужно заключить часть регулярки в круглые скобки.

        # Давайте попробуем на практике. Пусть у нас есть следующая строка:

'''
txt = '123 456'

        # Давайте разложим подстроки с числами по карманам. Для этого напишем следующую регулярку:

res = re.search('(\\d+) (\\d+)', txt)

        # В результате мы получим match-объект. В его элементе с индексом 1 будет лежать первый карман, в элементе с индексом 2 - второй карман, а в элементе с индексом 0 - все найденное (так называемый нулевой карман):


print(res)
print(res[0])
print(res[1])
print(res[2])
'''

    # 1

# Дана строка, содержащая домен: txt = 'sss domain.ru zzz' Найдите этот домен и положите его имя в первый карман, а зону - во второй.

'''
txt = 'sss domain.ru zzz'
res = re.search('([a-z]+)(\\.[a-z]+)', txt)
print(res)
print(res[0])
print(res[1])
print(res[2])
'''























































