    # Standard features Стандартные функции

import math
import random

    #Все методы модуля math вызываются только с предварительным импортом модуля math

    #Метод pow модуля math возвращает число, возведенное в степень. В первом параметре метода указываем нужное нам число, во втором параметре - в какую степень мы хотим его возвести. В отличие от оператора **, метод всегда возвращает вещественное число

    #Метод sqrt модуля math возвращает квадратный корень указанного в параметре числа. Всегда возвращается вещественное значение.

    # 172 Степень и корень

    # 1
'''
num_1 = 5
num_2 = 4

print(math.pow(num_1, num_2))
'''

    # 2
#дан словарь. Возведите каждый ключ в степень значения, чтобы получить следующий результат: 16.0 9.0 625.0
'''
dct = {
    2: 4,
    3: 2,
    5: 4
}

lst = []

for key, value in dct.items():
    lst.append(math.pow(key, value))
    print(math.pow(key, value))

print(lst)
'''

    # 3 
# Дано число: num = 16 Найдите квадратный корень из этого числа.
'''
num = 16
print(math.sqrt(num))
'''

    # 4
# Дан список: lst = [2, 3, 4] Найдите квадратный корень из суммы чисел данного списка.
'''
lst = [2, 3, 4]
res = 0
res_sqrt = 0
i = 0

for num in lst:
    res += num
#    i +=1
#    print(res)
#    if i == 2:
#        res_sqrt = math.sqrt(res)
#если разу найти корнеь в цикле то ответ будет равен 2.23606797749979, вне цикла будет 3, почему?
print(math.sqrt(res))
'''


    # 173 Функции округления

    # Функция round округляет число с плавающей точкой, указанное в первом параметре, до ближайшего целого числа по правилам математического округления. Во втором необязательном параметре функции можно сколько знаков нужно оставить в дробной части.

    # Метод floor модуля math производит округление числа до целых всегда в меньшую сторону.

    # Метод ceil модуля math производит округление числа до целых всегда в большую сторону.

# 1 Округлите эту дробь до целого.
'''
num = 16.456

print(round(num))
print(math.ceil(num))
print(math.floor(num))
'''

# 2 Округлите эту дробь до двух знаков в дробной части.
'''
num = 21.167

print(round(num, 2))
'''

# 3 Округлите эту дробь до целого в большую сторону.
'''
num = 3.348

print(math.ceil(num))
'''

# 4 Округлите эту дробь до целого в меньшую сторону.
'''
num = 18.565

print(math.floor(num))
'''

# 5 Найдите квадратный корень из этого числа и округлите результат до двух знаков в дробной части.
'''
num = 17

print(round(math.sqrt(num), 2))
'''

# 6 Найдите кубический корень из этого числа и округлите результат в большую сторону.
'''
num = 17
print(math.pow(num, 1/3))
print(math.ceil(math.pow(num, 1/3)))
'''

# 7 Округлите каждый его элемент до целого числа.
'''
lst_float = [3.45, 1.54, 5.76]
lst_round = []

for el in lst_float:
    lst_round.append(round(el))

print(lst_round)
'''

# 8 Напишите код, чтобы получить следующий результат: lst2 = [1, 4, 2]
'''
lst_1 = [1.514, 4.897, 2.657]
lst_2 = []

for el in lst_1:
    lst_2.append(math.floor(el))

print(lst_2)
'''

    # 174 Экстремальные числа в Python

    # Функция min возвращает минимальное число из группы чисел, заданных в параметрах. Можно задать группу чисел, перечислив их через запятую, либо последовательность: список, кортеж, сет.

    # Функция max возвращает максимальное число из группы чисел, заданных в параметрах. Можно задать группу чисел, перечислив их через запятую, либо последовательность: список, кортеж, сет.

# 1 Найдите в нем минимальное число.
'''
lst = list(range(2, 9, 2))

print(min(lst))
'''

# 2 Найдите в нем минимальное число.
'''
tpl = (-1, 2, -6, 3)

print(min(tpl))
'''

# 3 Найдите его максимальное значение.
'''
dct = {
    'a': 3,
    'b': 4,
    'c': 5,
    'd': 1
}

print(max(dct.values()))
'''

# 4 Выведите из него максимальную и минимальную цифру.
'''
num = 123456
num = str(num)

print(max(num), type(max(num)), int(max(num)), type(int(max(num))) )

num = int(num)
'''

    # 175 Рандом нужен import random

    # random.random random.randint random.uniform random.randrange random.choice random.sample random.shuffle random.seed

    # Метод random модуля random возвращает псевдослучайное число от 0.0 до 1.0. В параметр метода ничего не передаем. При каждом вызове метода будет возвращаться новое число.

    # Метод randint модуля random возвращает псевдослучайное целое число из заданного диапазона. В первом параметре метода указываем начальное значение диапазона, во втором - его конечное значение.

    # Метод uniform модуля random возвращает псевдослучайное вещественное число из заданного диапазона. В первом параметре метода указываем начальное значение диапазона, во втором - конечное значение.

    # Метод randrange модуля random возвращает случайное число из диапазона. В первом необязательном параметре метода указываем начало последовательности. Во втором обязательном параметре задаем конец. А в третьем необязательном параметре передаем шаг с которым будет выбираться число.

    # Метод choice модуля random возвращает случайный элемент из последовательности (строки, списка, кортежа). В параметре метода указываем нужную нам последовательность.

    # Метод sample модуля random возвращает случайную выборку элементов из последовательности. В первом параметре метода указываем последовательность, во втором параметре - количество элементов, которые мы хотим выбрать случайным образом.
    # В третьем необязательном именованном параметре k можем задать список элементов для повтора. Это позволяет повысить вероятность выборки заданных элементов. Обратите внимание на то, что третий параметр метода добавлен только начиная с версии Python 3.9. с версии Python 3.9 не предусмотрена возможность брать выборку из множества.

    # Метод shuffle модуля random перемешивает порядок элементов в изменяемой последовательности. Поскольку кортеж является неизменяемой последовательностью, а элементы в множестве неупорядочены, выходит, что метод работает только со списком. После выполнения метода исходный список изменяется, а сам метод возвращает None. В параметре метода передаем нужный нам список.

    # Метод seed модуля random инициализирует или сохраняет определенное случайное число. Для генерации случайных чисел метод использует текущее системное время ОС. Метод seed применяется до метода random. В необязательном параметре метода передается число для инициализации или своего рода маркировки сгенерированного числа. Поэтому при повторном применении метода random сгенерированное число не изменяется. Если же параметр оставить пустым, то будет генерироваться каждый раз новое число.


# 1 Сгенерируйте случайное целое число из диапазона, заданного нашими числами.
'''
num_1 = 10
num_2 = 20

print(random.randint(num_1, num_2))
'''

# 2 Сгенерируйте псевдослучайное целое число из диапазона, заданного нашими числами.
'''
num_1 = 5
num_2 = 30

print(random.randint(num_1, num_2))
'''

# 3 Сгенерируйте псевдослучайное вещественное число из диапазона, заданного нашими числами.
'''
num_1 = 1.345
num_2 = 14.784

print(random.uniform(num_1, num_2))
'''

# 4 Сгенерируйте случайное вещественное число из диапазона, заданного нашими числами.
'''
num_1 = -2
num_2 = 10

print(random.uniform(num_1, num_2))
'''

# 5 Сгенерируйте случайное число из диапазона, заданного первым и вторым числом. Третье число пусть определяет шаг выборки.
'''
num_1 = 5
num_2 = 50
num_3 = 4

print(random.randrange(num_1, num_2, num_3))
'''

# 6 Получите случайный элемент из этого списка
'''
lst = list(range(1, 6))

print(random.choice(lst))
'''

# 7 Получите новый список, состоящий из трех случайных элементов исходного списка.
'''
lst = list(range(1, 6))
lst_rnd = random.sample(lst, 3)

print(lst_rnd)
'''

# 8 Перемешайте элементы этого списка в случайном порядке.
'''
lst = list(range(1, 6))
random.shuffle(lst)

print(lst)
'''

# 9 Получите три случайных элемента из списка так, чтобы в выборке элементы не повторялись.
'''
lst = [1, 1, 1, 2, 2, 3, 3, 4, 5]
lst_clear = list(set(lst))

print(random.sample(lst_clear, k=3))
'''

# 10 Дано число Инициализируйте его.
'''
num = 7

random.seed(num)
print(random.random())
'''

# 11 Получите из него случайное число, а затем инициализируйте его.
'''
tpl = (10, 6, 2, 4)

random.seed(random.choice(tpl))

print(random.random())
'''

    # 176 Модули

# 1 Получите сумму их модулей.
'''
num_1 = -8
num_2 = -2 

print(abs(num_1) + abs(num_2))
'''

# 2 lst1 = [-3, 4, -1, 6] lst2 = [] Напишите код, чтобы получить следующий результат: lst2 = [3, 4, 1, 6]
'''
lst_1 = [-3, 4, -1, 6]
lst_2 = []

for num in lst_1:
    lst_2.append(abs(num))

print(lst_2)
'''

    # 177    Математические операции с числами

    # sum math.fsum math.factorial

    # функция sum возвращает сумму всех членов последовательности чисел. Тип возвращаемого значения зависит от складываемых чисел.

    # Метод fsum модуля math возвращает сумму всех членов последовательности чисел. Тип возвращаемого значения всегда дробный.

    # Метод factorial модуля math возвращает факториал числа, т.е. произведение всех натуральных чисел от 1 до заданного числа. В параметре метода можно передавать только положительное число, иначе метод вернет ошибку.

# 1 Найдите сумму элементов этого списка.
'''
lst = [1, 2, 3, 4, 5]

print(sum(lst))
'''

# 2 Найдите сумму элементов этого списка в виде дробного числа.
'''
st = {2.3, 4, 7.8}

print(math.fsum(st))
'''

# 3 Сгенерируйте случайное целое число из диапазона, заданного нашими числами. Затем получите его факториал.
'''
num_1 = 2
num_2 = 15
rnd_num = random.randint(num_1, num_2)

print(rnd_num, math.factorial(rnd_num))
'''

# 4 Найдите среднее арифметическое этого списка.
'''
lst = [1, 2, 3, 4, 5]

print('Среднее арифметическое ровно: ', sum(lst) / len(lst))
'''

    # 178 деление чисел

    # math.remainder math.fmod divmod math.modf

    # Метод remainder модуля math возвращает остаток от деления одного числа на второе. В первом параметре метода указываем число, которое нужно разделить (делимое), во втором параметре - число, на которое делим первое (делитель). В отличие от оператора % метод всегда возвращает вещественное значение.

    # Метод fmod модуля math возвращает остаток от деления числа с плавающей точкой. В первом параметре метода указываем число, которое нужно разделить (делимое), во втором параметре - число, на которое делим первое (делитель).

    # Функция divmod возвращает кортеж из частного (число, полученное от деления одного числа на другое) и остатка при делении. В первом параметре метода указываем число, которое нужно разделить (делимое), во втором параметре - число, на которое делим первое (делитель).

    # Метод modf модуля math возвращает кортеж, состоящий из дробной и целой частей заданного числа.

# 1 Найдите целый остаток от их деления.
'''
num_1 = 10
num_2 = 45

print(math.remainder(num_1, num_2), math.remainder(num_2, num_1))
'''

# 2 Найдите остаток от деления второго числа на первое. Полученным результатом должно быть число с плавающей точкой.
'''
num_1 = 12.4
num_2 = 30

print(math.fmod(num_1, num_2), math.fmod(num_2, num_1))
'''

# 3 Получите кортеж из результата деления и остатка от деления.
'''
num_1 = 5
num_2 = 3

print(divmod(num_1, num_2), divmod(num_2, num_1))
'''

# 4 Найдите кортеж из его дробной и целой частей.
'''
num = 2.34

print(math.modf(num))
'''

# 5 Получите список из его дробной и целой частей.
'''
num = 4.8

print(math.modf(num))
'''

    # 179 Регистр символов

    # lower upper swapcase capitalize casefold title

    # Метод lower возвращает строку, в которой все символы строки находятся в нижнем регистре. В параметре метода ничего не указываем.

    # Метод upper возвращает строку, в которой все символы строки находятся в верхнем регистре. В параметре метода ничего не указываем.

    # Метод swapcase возвращает строку, в которой все символы строки находятся в противоположном исходному регистре. Если символы были в верхнем регистре, то они приобретут нижний и соответственно наоборот. В параметре метода ничего не указываем.

    # Метод capitalize возвращает строку с первым символом в верхнем регистре, при этом все остальные символы будут находиться в нижнем регистре.

    # Метод casefold возвращает строку, в которой все символы строки находятся в нижнем регистре. В параметре метода ничего не указываем. В отличие от метода lower метод casefold работает только с символами в кодировке Unicode.

    # Метод title возвращает строку c первым символом в верхнем регистре для каждого слова, при этом все остальные символы будут находиться в нижнем регистре.

# 1 Сделайте все буквы в ней строчными
'''
txt = 'ABCDE'

print(txt.lower())
'''

# 2 Сделайте заглавными все буквы этой строки.
'''
txt = 'abcde'

print(txt.upper())
'''

# 3 Сделайте заглавной первую букву этой строки.
'''
txt = 'abcde'

print(txt.capitalize())
'''

# 4 Сделайте заглавными первые буквы каждого слова из этой строки:
'''
txt = 'word1 word2 word3'

print(txt.title())
'''

# 5 Поменяйте регистр символов на противоположный
'''
txt = 'ABC def'

print(txt.swapcase())
'''

# 6 Пусть каждый его элемент начинается с заглавной буквы.
'''
lst_1 = ['ab', 'Cd', 'eF']
lst_2 = []

for el in lst_1:
    lst_2.append(el.capitalize())

lst_1 = lst_2[:]
lst_2.clear()
print(lst_1)
'''

# 7 Пусть у вас есть словарь, в котором ключами являются имена пользователей, а значениями - их электронная почта. Напишите такой код, чтобы все буквы строк с почтой были строчными.
'''
dct = {
    'John': 'QSDsdAD@gmail.com',
    'Mali': 'JkJkjKJYgfFDe@gmail.com',
    'Yana': 'tyYUIjhGG@gmail.com',
    'Peter': 'YGbhjbBYY@gmail.com',
    'EFGHJ': 'DRrffRD@gmail.com'
}

#print(dct)


for key, value in dct.items():
    dct[key] = value.lower()
    #print(key, value)

print(dct)
'''

    # 180 Разбиения строк

    # split rsplit partition rpartition join

    # Метод split возвращает список из строки, разделенной слева по первому совпадению подстроки и указанного в параметре разделителя. Во втором необязательном параметре указываем сколько раз будем делить строку. По умолчанию можно делить строку неограниченное количество раз.

    # Метод rsplit возвращает список из строки, разделенной по последнему совпадению подстроки и указанного в параметре разделителя. Во втором необязательном параметре указываем сколько раз будем делить строку. По умолчанию можно делить строку неограниченное количество раз.

    # Метод partition возвращает кортеж из строки, разделенной по первому совпадению подстроки и указанного в параметре разделителя.

    # Метод rpartition возвращает кортеж из строки, разделенной по последнему совпадению подстроки и указанного в параметре разделителя.

    # Метод join сливает элементы списка в строку с указанным для них разделителем (пробелом, запятой и т.д.).

# 1 Напишите код, чтобы получить следующий результат: ['a', 'b', 'c', 'd']
'''
txt = 'a/b/c/d'

print(txt.split('/'))
'''

# 2 Напишите код, чтобы получить следующий результат: ['a.b.c', 'd']
'''
txt = 'a.b.c.d'

print(txt.rsplit('.', 1))
'''

# 3 Напишите код, чтобы получить следующий результат: ('ab', '%', 'cd%')
'''
txt = 'ab%cd%'

print(txt.partition('%'))
'''

# 4 Напишите код, чтобы получить следующий результат: ('2025-12', '-', '31')
'''
txt = '2025-12-31'

print(txt.rpartition('-'))
'''

# 6 Напишите код, чтобы получить следующую строку: 'abcd'
'''
lst = ['a', 'b', 'c', 'd']
txt = ''.join(lst)


print(txt)
'''

# 7 Напишите код, чтобы получить следующую строку: '2025/31/12'
'''
lst = ['2025', '31', '12']
txt = '/'.join(lst)

print(txt)
'''

#  8 Напишите код, чтобы получить следующую строку: '123'
'''
lst = [1, 2, 3]
lst_str = []

for num in lst:
    lst_str.append(str(num))

print(lst_str)
txt = ''.join(lst_str)
lst_str.clear()

print(txt, lst_str)
'''

    # 181 Форматирование строк

    # strip lstrip rstrip format zfill ljust rjust

    # Метод strip возвращает строку, в начале и конце которой удалены заданные символы. В необязательном параметре метода указываем тем символы, которые хотим удалить. Если их не указать, то метод удалит только пробелы в начале и конце строки.

    # Метод lstrip возвращает строку, в которой удалены заданные символы в начале. В необязательном параметре метода указываем тем символы, которые хотим удалить. Если их не указать, то метод удалит только пробелы в начале строки.

    # Метод rstrip возвращает строку, в которой удалены символы в ее конце. В необязательном параметре метода указываем те символы, которые хотим удалить. Если их не указать, то метод удалит только пробелы в конце строки.

    # Метод format подставляет данные с помощью форматирования строки. В параметре метода задаем нужное нам значение, которое заполнит пустые фигурные скобки в строке.

    # Метод zfill возвращает строку, заполненную нулями до заданной длины. Желаемая длина строки задается параметром метода.

    # Метод ljust возвращает строку, текст в которой заполнен и выравнен по левому краю. В первом параметре метода передаем число для указания длины строки, во втором необязательном параметре - символ-заполнитель, по умолчанию это пробел.

    # Метод rjust возвращает строку, текст в которой заполнение и выравнен по правому краю. В первом параметре метода передаем число для определения длины строки, во втором необязательном параметре - символ-заполнитель, по умолчанию это пробел.

# 1 Удалите из строки все единицы, чтобы получить следующий результат: ['a', 'b', 'c', 'd']
'''
txt = 'a1bc11de'
txt_cleaned = txt.replace('1', '')
lst = []
lst_2 = []

#пример без методов строк
for let in txt:
    
    if let == '1':
        continue
    else:
        lst_2.append(let)

for let in txt_cleaned:
    lst.append(let)

print(lst, lst_2)
'''

# 2 Дана строка с концевыми пробелами: txt = ' abcde ' Удалите пробелы с ее концов: 'abcde'
'''
txt = ' abcde '

print(txt.strip())
'''

# 3 Дана строка с концевыми пробелами: txt = ' abcde ' Удалите пробелы слева: 'abcde '
'''
txt = ' abcde '

print(txt.lstrip())
'''

# 4 Дана строка с концевыми пробелами: txt = ' abcde ' Удалите пробелы справа: ' abcde'
'''
txt = ' abcde '

print(txt.rstrip())
'''

# 6 Даны строка и число: txt = 'abc {}'num = 12 Подставьте в строке вместо фигурных скобок число.
'''
txt = 'abc {}'
num = 12

print(txt.format(num))
'''

# 8 Дана пустая строка: txt = '' Дана переменная: num = 6 Запишите в строку столько нулей, какое значение содержится в нашей переменной: '000000'
'''
txt = ''
num = 6

print(txt.zfill(num))
'''

# 9 Дана строка: txt = 'abcde' Напишите код, чтобы получить следующий результат: 'abcde111'
'''
txt = 'abcde'

print(txt.ljust((len(txt)+3), '1'))
'''

# 10 Дана строка: txt = '12345' Напишите код, чтобы получить следующий результат: 'aa12345'
'''
txt = '12345'

print(txt.rjust((len(txt)+2), 'a'))
'''

    # 182 Поиск по строкам

    # Метод startswith проверяет, начинается ли строка на указанную подстроку. Возвращает True или False. В первом параметре метода задаем нужную нам подстроку, во втором и третьем необязательных параметрах - индекс начала и конца поиска соответственно.

    # Метод endswith проверяет, заканчивается ли строка на указанную подстроку и возвращает значения True или False. В первом параметре метода задаем нужную нам подстроку, во втором и третьем необязательных параметрах - индекс начала и конца поиска соответственно.

    # Метод find возвращает индекс первого совпадения подстроки в строке. В первом параметре метода задаем нужную нам подстроку, во втором и третьем необязательных параметрах - индекс начала и конца поиска соответственно. Если подстрока не найдена, то метод вернет число -1.

    # Метод rfind возвращает индекс совпадения подстроки с конца строки. В первом параметре метода указываем строку или подстроку, которую хотим найти, во втором необязательном параметре - индекс начала поиска, в третьем необязательном параметре - индекс конца поиска. Если подстрока не найдена, метод вернет число -1.

    # Метод rindex возвращает наибольший индекс совпадения подстроки с конца строки. В первом параметре метода указываем строку или подстроку, которую хотим найти, во втором необязательном параметре - индекс начала поиска, в третьем необязательном параметре - индекс конца поиска. В отличие от метода rfind метод rindex выбрасывает исключение ValueError, если подстрока не найдена.

    # Метод index возвращает индекс первого совпадения подстроки в строке. В первом параметре метода задаем нужную нам подстроку, во втором и третьем необязательных параметрах - индекс начала и конца поиска соответственно. Если подстрока не найдена, то метод выбросит исключение.

    # Метод count возвращает количество вхождений подстроки в указанной строке. В первом параметре метода задаем нужную нам подстроку, во втором и третьем необязательных параметрах - индекс начала и конца поиска соответственно.

    # Метод replace осуществляет поиск и замену в строке. В первом параметре метода указываем подстроку, которую хотим заменить. Во втором параметре - чем хотим ее заменить. В третьем необязательном параметре можно задать количество замены подстроки.

# 1 Дана строка: txt = 'abcdef' Проверьте, начинается ли эта строка на 'ac'.
'''
txt = 'abcdef'

print(txt.startswith('ac',))
'''

# 2 Дан список: lst = ['12', '13', '14', '15'] Проверьте, начинаются ли его элементы на '1'.
'''
lst = ['12', '13', '14', '15']

for el in lst:
    print(el.startswith('1'))
'''

# 3 Дано число: num = 123456 Проверьте, есть ли в его конце шестерка.
'''
num = 123456
str_num = str(num)

print(str_num.endswith('6'))
'''

# 4 Дана строка: txt = 'abcdef' Узнайте индекс символа 'c'.
'''
txt = 'abcdef'

print(txt.index('c'))
print(txt.find('c'))
'''

# 5 Дана строка: txt = 'ab1cd1ef' Узнайте индекс символа '1', при этом проведите поиск с третьего по седьмой символ строки.
'''
txt = 'ab1cd1ef'

print(txt.find('1', 2, 6))
print(txt.rfind('1'))
'''

# 6 Узнайте индекс последнего совпадения символа '3'.
'''
txt = '123453637'

print(txt.rfind('3'))
print(txt.rindex('3'))
'''

# 7 Узнайте индекс последнего совпадения символа '2'.
'''
txt = '2025.12.31'

print(txt.rfind('2'))
print(txt.rindex('2'))
'''

# 8 Узнайте сколько в нем пятерок.
'''
num = 24536589
str_num = str(num)

print(str_num.count('5'))
'''
'''
# 9 Узнайте сколько в каждом из его элементов символов 'b'.

lst = ['abc', 'cde', 'cbb', 'aeb']
count_b = 0

for el in lst:
    count_b += el.count('b')
    print('В данном элементе', el.count('b'), ' буква(-ы) b')

print('Всего букв b: ', count_b)
'''

# 10 Дана строка: txt = 'http1://code.mu' Напишите код, чтобы получить следующий результат: txt = 'https://code.mu'
'''
txt = 'http1://code.mu'
txt_fixed = txt.replace('1', 's')

print(txt_fixed)
'''

# 11 Замените в ней все точки пробелами.
'''
txt = 'a.bc.d.ef'
txt_spaces = txt.replace('.', ' ')

print(txt_spaces)
'''

    # 183 Проверка строки

    # Метод istitle проверяет первый символ каждого слова в строке на верхний регистр. В параметры метода ничего не передается. Метод возвращает булевые значения True или False.

    # Метод isupper проверяет все символы строки на верхний регистр. В параметры метода ничего не передается. Метод возвращает булевые значения True или False.

    # Метод islower проверяет, имеют ли все символы строки нижний регистр. В параметры метода ничего не передается. Метод возвращает булевые значения True или False.

    # Метод isalpha проверяет, что строка состоит только из букв. В параметры метода ничего не передается. Метод возвращает булевые значения True или False.

    # Метод isalnum проверяет что символы строки являются только буквами и цифрами. В параметры метода ничего не передается. Метод возвращает значения True или False.

    # Метод isdigit проверяет, что строка состоит только из цифр. В параметры метода ничего не передается. Метод возвращает булевые значения True или False.

    # Метод isnumeric проверяет входят ли в строку только числа. В отличие от метода isdigit метод isnumeric проверяет вхождение в строку всех типов числовых значений, включая римские цифры и дроби. В параметры метода ничего не передается. Метод возвращает булевые значения True или False.

    # Метод isspace проверяет входят ли в строку только пробелы. Помимо пробелов, метод распознает следующие символы - '\t' (горизонтальный отступ), '\n' (новая строка), '\v' (вертикальный отступ), '\f' (переход вниз к следующей странице), '\r' (возврат к началу строки). В параметры метода ничего не передается. Метод возвращает булевые значения True или False.

# 1 Проверьте, что она начинается с заглавной буквы.
'''
txt = 'Abcde'

print(txt.istitle())
'''

# 2 Проверьте, начинается ли каждый его элемент с заглавной буквы.
'''
lst = ['User1', 'User2', 'user3', 'User4']

for el in lst:
    if el.istitle():
        print('title')
    else:
        print('not title')
'''

# 3 Проверьте, что все ее буквы находятся в верхнем регистре.
'''
txt = 'ABCDE'

print(txt.isupper())
'''

# 4 Проверьте, что все ее буквы находятся в нижнем регистре.
'''
txt = 'abcde'

print(txt.islower())
'''

# 5 Проверьте, что она состоит только из букв.
'''
txt = 'abcde'

print(txt.isalpha())
'''

# 6 Проверьте, что она состоит только из цифр.
'''
txt = '12345'

print(txt.isdigit())
'''

# 7 Проверьте, что она состоит только из цифр.
'''
txt = 'Ⅷ'

print(txt.isnumeric())
'''

# 8 Проверьте, что она состоит только из букв и цифр.
'''
txt = '12345abc'

print(txt.isalnum())
'''

# 9 Проверьте, что она состоит только из букв и цифр.
'''
txt = 'a1b2c3d '

print(txt.isalnum())
#False bc of space
'''

# 10 Проверьте, состоит ли она только из пробелов.
'''
txt = ' '

print(txt.isspace())
'''

# 11 Проверьте, есть ли в нем элементы, содержащие только пробелы.
'''
lst = ['a', 'b', ' ', 'c', '']

for el in lst:
    if el.isspace():
        print('only space')
    else:
        print('not only space')
'''