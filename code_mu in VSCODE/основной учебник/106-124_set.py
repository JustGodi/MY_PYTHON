#Множество - изменяемый тип данных, предназначенный для хранения только уникальных значений. Внешне множество похоже на список, только его элементы заключены в фигурные скобки. Синтаксис множества выглядит так:
'''
st = {1, 2, 3, (1, 2, 3), '1', '2', '3', 2.01, 4.55, True, False}
print(st)
'''
#Чтобы создать мноество нужно обязательно прменить функцию set(), если в параметры ничего не укзать, то создастя пустое множество
'''st_1 = set()
print(st_1)'''
#Если же задать переменной пустые фигурные скобки, то бедт создан пустой словарь
'''st_1 = {}
st_2 = set()
print(st_1, type(st_1), st_2, type(st_2))'''
#Чтобы создать множество, заполненное элементами нужно указать их в параметре функции set. Множество можно сделать из строки, массива и кортежа
'''
st_1 = set('abc')
st_2 = set(['1', '2', '3', 1, 2, 3])
st_3 = set((1, 2, 3))
print(st_1)
print(st_2)
print(st_3)
'''
'''
tst = {'a': 1, 'b': 2, 'c': 3}
print(tst, type(tst))
'''

#элемент множества в пайтон. множество является неупорядоченным. все элементы располагаются произвольно и не имеют индексов. так же при выводе множества последовательность его элементов будет меняться. Нельзя обращаться по индексу множества к элементу
#st = {'a', 'b', 'c', 'd'}
##print(st[0])
#ошибка
#print(st['a'])
#ошибка

#ПОВТОРЯЮЩИЕСЯ ЭЛЕМЕНТЫ В МНОЖЕСТВЕ. В множестве нельзя хранить повторяющиеся элементы. Если их задать то они будут удалены.
'''
st = {1, 1, 1, 2, 2, 2, 3, 3, 3}
print(st)
'''

#длину множества можно узнать при помощи функции len()
'''
st = {'a', 'b', 'c', 1, 2, 3}
print(len(st))
'''

#добавление элемента в множество при помощи метода .add(value), 1 argument
'''st = {'a', 'b', 1, 2}
print(st)
st.add('e')
st.add(3)
st.add((1, 2, 3))
st.add(('a', 'b', 'c'))
st.add(1.01)
st.add(5.34567890)
print(st)'''
'''
st_1 = set()
txt_1 = 'xyz'
txt_2 = 'xzy'
txt_3 = 'zxy'
print(st_1)
st_1.add(txt_1)
st_1.add(txt_2)
st_1.add(txt_3)
print(st_1)
'''

#Добавление нескольких элементов в множество при помощи метода .update()
'''
st_1 = {'q', 'd', 'f', 'n'}
print(st_1)
#Если передать в метод .update() строку, то она добавится к множеству как много разных элементов из которых состоит строка
st_1.update('xyz')
print(st_1)
#В параметры метода .update() можно задавать список для добавления
st_1.update([1, 2, 3, 4, 5])
#И они будут добавлены тоже как отдельные элементы множества
print(st_1)
#При передачи словаря в множество в него будут переданы только его ключи
dct_1 = dict(a = 1, b =2, c =3)
st_1.update(dct_1)
print(st_1)
#элементы картежей тоже можно добавить в множество, они тоже будут добавлены по отдельности
tpl_1 = (11, 12, 13)
st_1.update(tpl_1)
print(st_1)
'''
'''
st_1 = set()
st_1.update('xyzw')
print(st_1)
st_1.update('abxcz')
print(st_1)
'''
'''
st_1 = {1, 2, 3}
lst_1 = [3, 4, 5, 6]
print(st_1)
st_1.update(lst_1)
print(st_1)
'''

#объединение множеств при помощи метода .update()
'''
st_1 = {'a', 'b', 'c', 'd'}
st_2 = {1, 2, 3, 4, 5}
print(st_1)
print(st_2)
#st_1.update(st_2)
#print(st_1)
#print(st_2)
#в метод .update() можно передать несколько множеств
st_3 = {'x', 'y', 'z'}
#st_1.update(st_2, st_3)
#print(st_1, st_2, st_3)
#запись обхединения множеств можно сократить использовав оператор |
#st_4 = st_1 | st_2 | st_3
print(st_4)
'''

#удаление элемента из множества при помощи метода .remove(), в каестве параметра задаётся элемент оторый надо удалить
'''
st_1 = {'a', 'b', 'c', 1, 2, 3}
print(st_1)
st_1.remove('a')
st_1.remove(1)
print(st_1)
st_dlt = st_1.remove(2)
print(st_1, st_dlt)
'''
#Если элемента, который нужно удалить, нет в множестве, то вернется ошибка:

#альтернативный метод удаления элемента из множества это метод .discard(). Единственное отличие от .remove() в том, что не вернет ошибку если элемента нет в множестве, как в случае с методом .remove()
'''
st_1 = {1, 2, 3, 'a', 'b', 'c'}
print(st_1)
st_1.discard(1)
st_1.discard('a')
print(st_1)
st_1.discard('d')
print(st_1.discard('d'))
print(st_1)
'''
#не выдало ошибку ниже приведен код когда выдаст ошибку
#st_1.remove('d')
#print(st_1)

#извлечение случайного элемента из множества при помощи метода .pop() и последующее удаление элемента из множества
'''
st_1 = {'a', 'b', 'c'}
print(st_1)
st_1_dlt = st_1.pop()
print(st_1, st_1_dlt)
'''
'''
st_1 = {'a1', 'b2', 'c3', 'd4'}
print(st_1)
st_1_dlt_1 = st_1.pop()
st_1_dlt_2 = st_1.pop()
print(st_1, st_1_dlt_1, st_1_dlt_2)
'''

#удаление всех элеентов из множества при помощи метода .clear()
'''
st_1 = {1, 2, 3, 4, 5}
print(st_1)
st_1.clear()
print(st_1)
'''

#проверка элемента в множестве при промощи оператора in
'''
st_1 = {1, 2, 3, 4, 5}
st_2 = {1, 2, 3, 4, 5, 6}
res_1 = 1 in st_1
res_2 = '1' in st_1
res_3 = 1 in st_1 & st_2
res_4 = 6 in st_1 & st_2 #оператор и, выведет фолс логично 
res_5 = 6 in st_1 | st_2 #оператор или, выведет тру логично
res_6 = 6 not in st_1 & st_2
res_7 = 6 not in st_1 | st_2
print(res_1, res_2, res_3, res_4, res_5)
print(res_6, res_7)
num_1 = 1
res_8 = num_1 in st_1 & st_2
print(res_8)
print(num_1 not in st_1 & st_2)
'''

#в python есть возможность проверить входят ли элементы множества в какую-либо последовательность - другое множествоБ строкуБ списокБ кортеж при помощи метода .issubset, в параметре метода нужно указать другую последовательность, если множество входит в последовательность то выведет True, если нет то False
'''
st_1 = {1, 2, 3}
lst_1 = [1, 2, 3]
tpl_1 = (1, 2, 3)
st_2 = {1, 2, 3}
st_3 = {1, 2, 4}
res_1 = st_1.issubset(lst_1)
print(res_1)
res_2 = st_1.issubset(tpl_1)
print(res_2)
res_3 = st_1.issubset(st_2)
print(res_3)
res_4 = st_1.issubset(st_3)
print(res_4)
#у метода есть короткая форма записи и применяется она только при сравнении с множеством
res_5 = st_1 <= st_2
res_6 = st_1 <= st_3
print(res_5, res_6)
'''
'''
st_1 = {'1', '2', '3', '4', '5'}
txt_1 = '123456'
st_2 = set(txt_1)
res_1 = st_1 <= st_2
print(res_1)
st_3 = {'1', '2', '3'}
res_2 = st_1 <= st_2
print(res_2)
res_3 = st_2 <= st_1
print(res_3)
'''

#сравнение множеств при помощи оператора ==. Если множества ровны друг другу то True, если нет то False
'''
st_1 = {1, 2, 3, 4, 5}
st_2 = {5, 4, 3, 2, 1}
st_3 = {'1', '2', '3', '4', '5'}
res_1 = st_1 == st_2
res_2 = st_1 == st_3
print(res_1, res_2)
'''

#поиск одиннаковых элементов у двух множеств при помощи метода .intersection(), в его параметры задаётся множество с которым идет сравнение
'''
st_1 = {1, 2, 3, 'a', 'b', 'c'}
st_2 = {1, 4, 5, 'b', 'd', 'e'}
res_1 = st_1.intersection(st_2)
print(res_1, type(res_1)) 
#в качестве результата выводит множество из совпадений
#так же есть короткая форма записи, только для множеств
res_2 = st_1 & st_2
print(res_2, type(res_2))
'''
'''
st_1 = {1, 2, 3 ,4}
st_2 = {1, 2, 4, 5}
st_3 = {1, 2, 5, 7}
res_1 = st_1 & st_2 & st_3
print(res_1)
'''

#помимо одиннаковых элементов в множествах можно искать и те элементы по которым они отличаются при помощи метода .symmetric_difference() в параметр указывается множество с которым идёт сравнение
'''
st_1 = {1, 2, 3, 'a', 'b', 'c'} 
st_2 = {1, 2, 4, 'a', 'b', 'd'}
res_1 = st_1.symmetric_difference(st_2)
print(res_1, type(res_1))
#более короткая форма записи
res_2 = st_1 ^ st_2
print(res_2, type(res_2))
'''
'''
st_1 = {'a', 'b', 'c', 'd', 'e'}
st_2 = {'d', 'e', 'f', 'g', 'h'}
res_1 = st_1.symmetric_difference(st_2)
res_2 = st_1 ^ st_2
print(res_1, res_2)
'''
'''
st_1 = {2, 4, 8, 10}
st_2 = {1, 8, 3, 2}
st_3 = {4, 7, 3, 1}
st_4 = st_1 ^ st_2
print(st_4)
st_5 = st_3 ^ st_4
print(st_5)
'''

#поиск элементов, по которым одно множество отличается от другого(разность множеств). ГЛАВНОЕ ОТЛИЧИЕ ОТ ПРЕДЫДУЩЕГО МЕТОДА В ТОМ ЧТО, .SYMMETRIC_DIFFERENCE() ВЫДАЕТ ЭЛЕМЕНТЫ ПО КОТОРЫМ ПЕРВОЕ МНОЖЕСТВО ОТЛИЧАЕТСЯ ОТ ВТОРОГО И ВТОРОЕ МНОЖЕСТВО ОТ ПЕРВОГО. А вот метод .difference() показывает ем отличается первое множество от второго и всё
'''
st_1 = {1, 2, 3, 4}
st_2 = {3, 4, 5, 6}
res_1 = st_1.difference(st_2)
res_2 = st_2 - st_1
res_3 = st_1.symmetric_difference(st_2)
print(res_1, res_2, res_3)
'''
'''
st_1 = {'1', '3', '5'}
st_2 = {'6', '8', '1', '3'}
res_1 = st_2 - st_1
res_2 = st_2.difference(st_1)
print(res_1, res_2)
'''
'''
st_1 = {'a', 'b', 'c', 'd', 'e'}
st_2 = {'d', 'e', 'f', 'g', 'h'}
res_1 = st_1.difference(st_2)
res_2 = st_1 - st_2
print(res_1, res_2)
'''
'''
st_1 = {1, 2, 4, 5}
st_2 = {1, 2, 3, 6}
st_3 = {1, 2}
res_1 = st_1 - st_3
res_2 = st_2 - st_3
res_1.update(res_2)
#print(type(st_1), type(st_2), type(st_3))
#print(st_1, st_2, st_3)
print(res_1)
'''
'''
st_1 = {1, 3, 6, 8}
st_2 = {5, 8, 10, 2}
st_3 = {12, 7, 3, 1}
st_4 = st_1 - st_2
print(st_4)
res_1 = st_3.intersection(st_4)
print(res_1)
'''

#сложные операции с множествами. комбинирование ранее изученных коротких форм запсиси
'''
st_1 = {1, 2, 3, 4}
st_2 = {3, 4, 1, 6}
st_3 = {1, 2, 8, 4}
res_1 = st_1 & st_2 & st_3
print(res_1)
#а теперь снаала узнаем элементы первого множества отличаются от второго, а потом найдём одинаковые у нашего резуьтата и третьего множества
res_2 = (st_1 - st_2) & st_3
print(res_2)
'''
'''
st_1 = {1, 3, 6, 8}
st_2 = {5, 8, 4, 2}
st_3 = {4, 7, 3, 1}
st_1.update(st_2)
print(st_1)
st_4 = st_3 & st_1
print(st_4)
'''
'''
st_1 = {4, 2, 6, 10}
st_2 = {1, 6, 3, 2}
st_3 = {5, 8}
st_4 = {6, 3, 1}
res_1 = st_1 - st_2
res_2 = st_2 - st_1
st_3.update(st_4)
print(st_3)
res_3 = st_3 & res_1
res_4 = st_3.intersection(res_2)
print(res_3, res_4)
'''

#преобразования в множества
'''
txt_1 = 'abcde'
lst_1 = [1, 2, 3, 4, 5]
tpl_1= tuple('12345')
dct_1 = dict(a = 1, b = 2, c = 3, d = 4, e = 5)
st_txt_1 = set(txt_1)
st_lst_1 = set(lst_1)
st_tpl_1 = set(tpl_1)
st_dct_1 = set(dct_1)
print(st_dct_1, st_lst_1, st_tpl_1, st_txt_1)
'''